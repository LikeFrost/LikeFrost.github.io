
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>摸鱼日志 || 记录一些日常学习及奇奇怪怪的事情</title>
    <meta name="author" content="Like Frost">
    <meta name="description" content="吾生也有涯，而知也无涯 ">
    <meta name="keywords" content="编程,coding,个人博客 ">
    <link rel="icon" href="/images/avatar.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">摸鱼日志</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="outlined" />
            </span>
            <span>首页</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="outlined" />
            </span>
            <span>标签</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="ordered-list" theme="outlined" />
            </span>
            <span>归档</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>摸鱼日志</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="outlined" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">首页</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="outlined" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">标签</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="ordered-list" theme="outlined" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">归档</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('/home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>摸鱼日志</h1>
                <h3>记录一些日常学习及奇奇怪怪的事情</h3>
                <h5>吾生也有涯，而知也无涯</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/随机面试题/">
        <h2>
            随机面试题
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/3/6
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <span id="more"></span>

<ul>
<li><p><strong>JavaScript作用域和闭包</strong><br>Q：解释 JavaScript 中的词法作用域（Lexical Scoping）和闭包（Closure）。闭包是如何工作的，它们在实际开发中有哪些用途？<br>A：词法作用域是指一个函数的内部作用域，闭包是函数以及其周围的此法环境，它通常是一个函数，这个函数能访问外部的变量，因此这个变量一直存续在函数存续期间；在实际开发过程中，闭包可以用于将函数和他词法环境绑定，比如计算长方形的面积，当他的宽固定时，就可以写作：</p>
<pre><code class="js">function calcArea(width)&#123;
    return (height)=&gt;&#123;
        return width*height;
    &#125;
&#125;
const area = calcArea(10);
area(20);
</code></pre>
<p>另外，闭包也用于节流、防抖等，但要注意错误的使用闭包会造成内存泄漏。<br>C：实际应用：数据封装（模拟私有变量）、函数柯里化、事件处理器和回调函数</p>
</li>
<li><p><strong>异步编程</strong><br>Q：解释 <code>Promise</code> 和 <code>async/await</code> 在 JavaScript 中的作用。如何使用它们处理异步操作？请给出一个使用 <code>async/await</code> 处理 HTTP 请求并捕获错误的示例代码。<br>A：由于js是单线程的，所以一些网络请求等需求需要异步实现，最早使用的方式是回调函数，但是当一个回调函数依赖于另一个回调函数的时候，就会造成回调地狱，promise为了解决这一问题出现，promise的构造函数接受resolve和reject两个参数；async/await是promise的语法糖，实现了用同步的写法实现异步请求。<br>C：promise是一个代表了异步操作最终完成或失败的对象。</p>
<p>示例代码：</p>
<pre><code class="js">async function getData()&#123;
    try&#123;
        const res = await axios.get(&quot;xx&quot;);
        console.log(res);
    &#125;catch(err)&#123;
        console.log(err);
    &#125;
&#125;
getData();
</code></pre>
</li>
<li><p><strong>CSS布局</strong><br>Q：描述 Flexbox 和 Grid 布局的主要区别。你更倾向于在什么情况下使用 Flexbox，什么情况下使用 Grid？<br>A：flex是弹性盒子，gird是栅格布局，flex较为灵活。<br>C：flexbox是一种布局方法，意味着它能够处理元素在一个方向上的空间分配，flex设计的初衷是为了提供一种有效的方式来布局、对齐和分配在容器中的项目空间，即使大小是未知或动态变化的。 一维布局；<br>grid是二维布局。</p>
</li>
<li><p><strong>前端性能优化</strong><br>Q：列举至少五种你可以用来提高网页性能的方法或技术。请解释为什么这些方法会影响性能，并且你是如何决定哪些方法最适合当前项目的。<br>A：1. 使用精灵图，当前端使用较多小尺寸icon的时候，可以考虑把这些合并成一个较大的精灵图，避免多次请求服务器资源；2. 首屏加载优化，可以使用服务端渲染（ssr），加载首屏时直接渲染服务端返回的html，避免因计算样式或加载js脚本影响加载速度； 3. 减少页面的重排和重绘，尽量避免使用table，因为table中一个小的变化会引起整个页面的重排； 4. 使用缓存，当资源未发生改变时，使用本地缓存可以提高用户体验； 5. 开启gzip加速，前端资源通过gzip打包放在服务器上，减少文件体积，加快获取速度。<br>C：决定使用什么优化技术：分析网站或应用的性能瓶颈。</p>
</li>
<li><p><strong>Web安全</strong><br>Q：解释跨站脚本攻击（XSS）和跨站请求伪造（CSRF）的区别。你会如何防御这两种攻击？<br>A： XSS是通过在url、文本字段中注入script脚本实现的，比如在访问页面网址时携带参数，参数内包含script脚本，页面通过参数解析，执行恶意脚本；或者在评论区内提交一段script脚本，看到的用户都会遭受攻击；<br>CSRF是利用用户的授权信息去伪造请求，比如引导用户点击危险网站，恶意脚本会利用用户的身份认证去伪造危险行为。<br>为了防范XSS，可以对js代码进行转义、过滤用户输入等；防范CSRF可以防止页面注入iframe、使用csrf token验证等。</p>
</li>
</ul>
<hr>
<h3 id="1-实现一个-Promise-all"><a href="#1-实现一个-Promise-all" class="headerlink" title="1. 实现一个 Promise.all"></a>1. 实现一个 Promise.all</h3><p><strong>题目</strong>：请手写实现一个 <code>Promise.all</code> 函数，该函数接收一个 Promise 对象的数组作为参数，并返回一个新的 Promise 实例。新的 Promise 实例在所有输入 Promise 都成功解决时解决，返回值是一个包含所有输入 Promise 解决值的数组。如果任何一个输入 Promise 被拒绝，新的 Promise 立即拒绝，拒绝的原因是第一个拒绝的 Promise 的原因。</p>
<pre><code class="js">function promiseAll(promises) &#123;
  let result = new Array(promises.length);
  let success = 0;
  return new Promise((resolve, reject) =&gt; &#123;
    promises.forEach((promise, index) =&gt; &#123;
      promise
        .then((res) =&gt; &#123;
          result[index] = res;
          success++;
          if (success === promises.length) &#123;
            resolve(result);
          &#125;
        &#125;)
        .catch((e) =&gt; &#123;
          reject(e);
        &#125;);
    &#125;);
  &#125;);
&#125;
function promiseAllSettled(promises) &#123;
  let result = new Array(promises.length);
  let count = 0;
  return new Promise((resolve, reject) =&gt; &#123;
    promises.forEach((promise, index) =&gt; &#123;
      promise
        .then((res) =&gt; &#123;
          result[index] = &#123; state: &quot;fulfilled&quot;, value: res &#125;;
          count++;
          if (count === promises.length) &#123;
            resolve(result);
          &#125;
        &#125;)
        .catch((err) =&gt; &#123;
          result[index] = &#123; state: &quot;rejected&quot;, err &#125;;
          count++;
          if (count === promises.length) &#123;
            resolve(result);
          &#125;
        &#125;);
    &#125;);
  &#125;);
&#125;

let p1 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&quot;p1&quot;);
  &#125;, 1000);
&#125;);
let p2 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&quot;p2&quot;);
  &#125;, 2000);
&#125;);
let p3 = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    reject(&quot;p3&quot;);
  &#125;, 3000);
&#125;);
promiseAll([p1, p2, p3])
  .then((res) =&gt; &#123;
    console.log(res);
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err);
  &#125;);
promiseAllSettled([p1, p2, p3])
  .then((res) =&gt; &#123;
    console.log(res);
  &#125;)
  .catch((err) =&gt; &#123;
    console.log(err);
  &#125;);
</code></pre>
<h3 id="2-实现一个简单的路由"><a href="#2-实现一个简单的路由" class="headerlink" title="2. 实现一个简单的路由"></a>2. 实现一个简单的路由</h3><p><strong>题目</strong>：在不使用任何前端路由库的情况下，如何实现一个简单的前端路由（SPA）功能？请描述你的思路，并给出基本的实现代码。</p>
<h3 id="3-实现防抖（Debounce）函数"><a href="#3-实现防抖（Debounce）函数" class="headerlink" title="3. 实现防抖（Debounce）函数"></a>3. 实现防抖（Debounce）函数</h3><p><strong>题目</strong>：请实现一个防抖（Debounce）函数。防抖函数接收一个函数和等待时间作为参数，并返回一个新的函数。返回的新函数在被连续调用时，只有在等待时间过去后才会执行原函数，如果在等待时间内再次被调用，则重新计时。</p>
<pre><code class="js">function debounce(func, wait) &#123;
  let timeout = null;
  return function () &#123;
    clearTimeout(timeout);
    let arg = arguments;
    let _this = this;
    timeout = setTimeout(() =&gt; &#123;
      func.apply(_this, arg);
    &#125;, wait);
  &#125;;
&#125;

let add = (a, b) =&gt; &#123;
  console.log(a + b);
&#125;;
const debounceAdd = debounce(add, 1000);
setTimeout(() =&gt; &#123;
  debounceAdd(1, 2);
&#125;, 200);
setTimeout(() =&gt; &#123;
  debounceAdd(1, 2);
&#125;, 200);
</code></pre>
<h3 id="4-实现一个简单的模板引擎"><a href="#4-实现一个简单的模板引擎" class="headerlink" title="4. 实现一个简单的模板引擎"></a>4. 实现一个简单的模板引擎</h3><p><strong>题目</strong>：实现一个简单的模板引擎，它能够将类似于 <code>&quot;Hello, &#123;&#123;name&#125;&#125;!&quot;</code> 的模板字符串和一个对象如 <code>&#123;name: &quot;World&quot;&#125;</code> 作为输入，并输出 <code>&quot;Hello, World!&quot;</code>。请描述你的实现思路，并给出代码。</p>
<h3 id="5-CSS-垂直居中的方法"><a href="#5-CSS-垂直居中的方法" class="headerlink" title="5. CSS 垂直居中的方法"></a>5. CSS 垂直居中的方法</h3><p><strong>题目</strong>：请列举至少三种使得一个元素在其父元素中垂直居中的方法，并简要描述每种方法的原理和使用场景。</p>
<ul>
<li>深拷贝</li>
</ul>
<pre><code class="js">const deepClone = (obj) =&gt; &#123;
  if (obj === null || typeof obj !== &quot;object&quot;) return obj;
  let result = Array.isArray(obj) ? [] : &#123;&#125;;
  for (let key in obj) &#123;
    if (obj.hasOwnProperty(key)) &#123;
      if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;
        result[key] = deepClone(obj[key]);
      &#125; else &#123;
        result[key] = obj[key];
      &#125;
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>手写instanceOf</li>
</ul>
<pre><code class="js">const myInstance = (left, right) =&gt; &#123;
  if (left !== &quot;object&quot; || left === null) return false;
  let proto = Object.getPrototypeOf(left);
  while (proto) &#123;
    if (proto === right.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  &#125;
  return false;
&#125;;
</code></pre>
<ul>
<li>手写new</li>
</ul>
<pre><code class="js">function myNew(fn, ...args) &#123;
  const obj = &#123;&#125;;
  obj.__proto__ = fn.prototype;
  let result = fn.apply(fn, args);
  return result instanceof Object ? result : obj;
&#125;
</code></pre>
<ul>
<li>实现简单ajax</li>
</ul>
<pre><code class="js">function ajax(options) &#123;
  const xhr = new XMLHttpRequest();
  options = options || &#123;&#125;;
  options.type = (options.type || &quot;GET&quot;).toUpperCase();
  options.dataType = options.dataType || &quot;json&quot;;
  const params = options.data;

  if (options.type === &quot;GET&quot;) &#123;
    xhr.open(&quot;GET&quot;, options.url + &quot;?&quot; + params, true);
    xhr.send(null);
  &#125; else if (options.type === &quot;POST&quot;) &#123;
    xhr.open(&quot;POST&quot;, options.url, true);
    xhr.send(params);
  &#125;

  xhr.onreadystatechange = function () &#123;
    if (xhr.readyState === 4) &#123;
      const status = xhr.status;
      if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123;
        options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML);
      &#125; else &#123;
        options.fail &amp;&amp; options.fail(status);
      &#125;
    &#125;
  &#125;;
&#125;

ajax(&#123;
  url: &quot;http://localhost:3000/api&quot;,
  type: &quot;GET&quot;,
  data: &#123;
    name: &quot;zhangsan&quot;,
    age: 18,
  &#125;,
  dataType: &quot;json&quot;,
  success: function (response, xml) &#123;
    console.log(response);
  &#125;,
  fail: function (status) &#123;
    console.log(status);
  &#125;,
&#125;);
</code></pre>
<ul>
<li>函数柯里化</li>
</ul>
<pre><code class="js">const curry = function (fn) &#123;
  return function curried(...args) &#123;
    if (args.length &gt; fn.length) &#123;
      return function () &#123;
        return curried(...args.concat([...arguments]));
      &#125;;
    &#125;
    return fn(...args);
  &#125;;
&#125;;
</code></pre>
<ul>
<li>节流和防抖</li>
</ul>
<pre><code class="js">function debounce(func, wait) &#123;
  let timeout = null;
  return function () &#123;
    let args = arguments;
    let _this = this;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() =&gt; &#123;
      func.apply(_this, args);
    &#125;, wait);
  &#125;;
&#125;

function throttle(func, wait) &#123;
  let timeout = null;
  return function () &#123;
    let args = arguments;
    let _this = this;
    if (!timeout) &#123;
      timeout = setTimeout(() =&gt; &#123;
        func.apply(_this, args);
        timeout = null;
      &#125;, wait);
    &#125;
  &#125;;
&#125;

function throttle(func, wait) &#123;
  let oldtime = Date.now();
  return function () &#123;
    let args = arguments;
    let _this = this;
    let newtime = Date.now();
    if (newtime - oldtime &gt;= wait) &#123;
      func.apply(_this, args);
      oldtime = Date.now();
    &#125;
  &#125;;
&#125;
</code></pre>
<ul>
<li>并查集</li>
</ul>
<pre><code class="js">function createUnionFind(size) &#123;
  const parent = new Array(size).fill(0).map((_, i) =&gt; i);

  function find(x) &#123;
    if (parent[x] === x) &#123;
      return x;
    &#125;
    parent[x] = find(parent[x]);
    return parent[x];
  &#125;

  function union(x, y) &#123;
    let rootX = find(x);
    let rootY = find(y);
    if (rootX !== rootY) &#123;
      parent[rootX] = rootY;
    &#125;
  &#125;

  function connected(x, y) &#123;
    return find(x) === find(y);
  &#125;

  return &#123;
    find,
    union,
    connected,
  &#125;;
&#125;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#00bcd4>
                前端
            </a>
        </span>
        
    </div>

    <a href="/随机面试题/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/LeetCode-Hot100/">
        <h2>
            LeetCode Hot100
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/2/26
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <span id="more"></span>

<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><ul>
<li>两数之和</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
var twoSum = function (nums, target) &#123;
  let map = new Map();
  for (let i = 0; i &lt; nums.length; i++) &#123;
    map.set(nums[i], i);
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (map.has(target - nums[i]) &amp;&amp; map.get(target - nums[i]) !== i) &#123;
      return [i, map.get(target - nums[i])];
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>字母异位词</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string[]&#125; strs
 * @return &#123;string[][]&#125;
 */
var groupAnagrams = function (strs) &#123;
  let map = new Map();
  for (let str of strs) &#123;
    if (map.has(str.split(&quot;&quot;).sort().join(&quot;&quot;))) &#123;
      map.get(str.split(&quot;&quot;).sort().join(&quot;&quot;)).push(str);
    &#125; else &#123;
      map.set(str.split(&quot;&quot;).sort().join(&quot;&quot;), [str]);
    &#125;
  &#125;
  return Array.from(map.values());
&#125;;
</code></pre>
<ul>
<li>最长连续序列(使用set和动态规划)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var longestConsecutive = function (nums) &#123;
  let set = new Set(nums);
  let result = 0;
  for (let num of nums) &#123;
    if (!set.has(num - 1)) &#123;
      let current = num;
      let count = 1;
      while (set.has(current + 1)) &#123;
        current++;
        count++;
      &#125;
      result = Math.max(result, count);
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var longestConsecutive = function (nums) &#123;
  if (nums.length == 0) &#123;
    return 0;
  &#125;
  let dp = [];
  let result = 1;
  dp[0] = 1;
  nums.sort((a, b) =&gt; a - b);
  for (let i = 1; i &lt; nums.length; i++) &#123;
    dp[i] = 1;
    if (nums[i] == nums[i - 1]) &#123;
      dp[i] = dp[i - 1];
    &#125;
    if (nums[i] == nums[i - 1] + 1) &#123;
      dp[i] = dp[i - 1] + 1;
    &#125;
    result = Math.max(result, dp[i]);
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>移动零</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;void&#125; Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) &#123;
  let a = 0;
  let b = 0;
  while (a &lt; nums.length) &#123;
    if (nums[a] !== 0) &#123;
      nums[b] = nums[a];
      b++;
    &#125;
    a++;
  &#125;
  while (b &lt; nums.length) &#123;
    nums[b] = 0;
    b++;
  &#125;
&#125;;
</code></pre>
<ul>
<li>盛最多水的容器(从两端往中间移动短板，因为多少水是由短板决定的，移动长板并不能改善)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; height
 * @return &#123;number&#125;
 */
var maxArea = function (height) &#123;
  let result = 0;
  let left = 0;
  let right = height.length - 1;
  while (left &lt; right) &#123;
    result = Math.max(
      result,
      (right - left) * Math.min(height[left], height[right])
    );
    if (height[left] &lt; height[right]) &#123;
      left++;
    &#125; else &#123;
      right--;
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>三数之和</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var threeSum = function (nums) &#123;
  let result = [];
  nums.sort((a, b) =&gt; a - b);
  for (let i = 0; i &lt; nums.length - 2; i++) &#123;
    if (i === 0 || nums[i] !== nums[i - 1]) &#123;
      let sum = 0 - nums[i];
      let left = i + 1;
      let right = nums.length - 1;
      while (left &lt; right) &#123;
        if (nums[left] + nums[right] === sum) &#123;
          result.push([nums[i], nums[left], nums[right]]);
          left++;
          right--;
          while (left &lt; right &amp;&amp; nums[left] === nums[left - 1]) left++; // 跳过重复元素
          while (left &lt; right &amp;&amp; nums[right] === nums[right + 1]) right--; // 跳过重复元素
        &#125; else if (nums[left] + nums[right] &lt; sum) &#123;
          left++;
        &#125; else &#123;
          right--;
        &#125;
      &#125;
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>接雨水(双指针，类似于打擂，永远是强者在台上)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; height
 * @return &#123;number&#125;
 */
var trap = function (height) &#123;
  let left = 0;
  let right = height.length - 1;
  let leftMax = 0;
  let rightMax = 0;
  let result = 0;
  while (left &lt; right) &#123;
    if (height[left] &lt; height[right]) &#123;
      if (height[left] &gt;= leftMax) &#123;
        leftMax = height[left];
      &#125; else &#123;
        result += leftMax - height[left];
      &#125;
      left++;
    &#125; else &#123;
      if (height[right] &gt;= rightMax) &#123;
        rightMax = height[right];
      &#125; else &#123;
        result += rightMax - height[right];
      &#125;
      right--;
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>无重复字符的最长字串</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;number&#125;
 */
var lengthOfLongestSubstring = function (s) &#123;
  let max = 0;
  let start = 0;
  let map = new Map();
  for (let i = 0; i &lt; s.length; i++) &#123;
    if (map.has(s[i])) &#123;
      start = Math.max(start, map.get(s[i]) + 1);
    &#125;
    max = Math.max(max, i - start + 1);
    map.set(s[i], i);
  &#125;
  return max;
&#125;;
</code></pre>
<ul>
<li>找到字符串中所有的字母异位词</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @param &#123;string&#125; p
 * @return &#123;number[]&#125;
 */
var findAnagrams = function (s, p) &#123;
  if (s.length &lt; p.length) return [];
  let result = [];
  let pMap = new Array(26).fill(0);
  let sMap = new Array(26).fill(0);
  for (let i = 0; i &lt; p.length; i++) &#123;
    sMap[s.charCodeAt(i) - 97]++;
    pMap[p.charCodeAt(i) - 97]++;
  &#125;
  for (let i = 0; i &lt;= s.length - p.length; i++) &#123;
    if (sMap.join(&quot;&quot;) === pMap.join(&quot;&quot;)) result.push(i);
    sMap[s.charCodeAt(i) - 97]--;
    sMap[s.charCodeAt(i + p.length) - 97]++;
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><ul>
<li>和为k的子数组(前缀和优化)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var subarraySum = function (nums, k) &#123;
  let result = 0;
  let sum = 0;
  let map = new Map();
  map.set(0, 1);
  for (let i = 0; i &lt; nums.length; i++) &#123;
    sum += nums[i];
    result += map.get(sum - k) || 0;
    map.set(sum, (map.get(sum) || 0) + 1);
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>滑动窗口最大值(单调队列-双端队列)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;number[]&#125;
 */
var maxSlidingWindow = function (nums, k) &#123;
  const q = [];
  const result = [];
  for (let i = 0; i &lt; k; i++) &#123;
    while (q.length &amp;&amp; nums[q[q.length - 1]] &lt;= nums[i]) &#123;
      q.pop();
    &#125;
    q.push(i);
  &#125;
  result.push(nums[q[0]]);

  for (let i = k; i &lt; nums.length; i++) &#123;
    while (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - 1]]) &#123;
      q.pop();
    &#125;
    q.push(i);
    while (q[0] &lt;= i - k) &#123;
      q.shift();
    &#125;
    result.push(nums[q[0]]);
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><ul>
<li>最大子数组和(类似于dp，当和小于0的时候就丢弃)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var maxSubArray = function (nums) &#123;
  let max = nums[0];
  let sum = 0;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (sum &lt; 0) &#123;
      sum = 0;
    &#125;
    sum += nums[i];
    max = Math.max(max, sum);
  &#125;
  return max;
&#125;;
</code></pre>
<ul>
<li>合并区间（排序）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; intervals
 * @return &#123;number[][]&#125;
 */
var merge = function (intervals) &#123;
  intervals.sort((a, b) =&gt; a[0] - b[0]);
  for (let i = 0; i &lt; intervals.length - 1; i++) &#123;
    if (intervals[i][1] &gt;= intervals[i + 1][0]) &#123;
      intervals[i][1] = Math.max(intervals[i][1], intervals[i + 1][1]);
      intervals.splice(i + 1, 1);
      i--;
    &#125;
  &#125;
  return intervals;
&#125;;
</code></pre>
<ul>
<li>轮转数组(注意处理k大于数组长度的情况)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;void&#125; Do not return anything, modify nums in-place instead.
 */
var rotate = function (nums, k) &#123;
  k = k % nums.length;
  nums.unshift(...nums.slice(nums.length - k));
  nums.splice(nums.length - k, k);
&#125;;
</code></pre>
<ul>
<li>除自身以外数组的乘积(前缀乘积和后缀乘积)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[]&#125;
 */
var productExceptSelf = function (nums) &#123;
  let pre = new Array(nums.length).fill(1);
  let post = new Array(nums.length).fill(1);
  let result = [];
  pre[0] = nums[0];
  for (let i = 1; i &lt; nums.length; i++) &#123;
    pre[i] = pre[i - 1] * nums[i];
  &#125;
  post[nums.length - 1] = nums[nums.length - 1];
  for (let i = nums.length - 2; i &gt;= 0; i--) &#123;
    post[i] = post[i + 1] * nums[i];
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    result.push(
      i === 0
        ? post[i + 1]
        : i === nums.length - 1
        ? pre[i - 1]
        : pre[i - 1] * post[i + 1]
    );
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>空间复杂度为o(1) ，利用输出数组作为后缀乘积</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[]&#125;
 */
var productExceptSelf = function (nums) &#123;
  let post = new Array(nums.length).fill(1);
  post[nums.length - 1] = nums[nums.length - 1];
  for (let i = nums.length - 2; i &gt;= 0; i--) &#123;
    post[i] = post[i + 1] * nums[i];
  &#125;
  let pre = 1;
  for (let i = 0; i &lt; nums.length - 1; i++) &#123;
    post[i] = post[i + 1] * pre;
    pre *= nums[i];
  &#125;
  post[nums.length - 1] = pre;
  return post;
&#125;;
</code></pre>
<ul>
<li>缺失的第一个正数(将现有数组想办法当成hash表)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var firstMissingPositive = function (nums) &#123;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (nums[i] &lt; 1 || nums[i] &gt; nums.length) &#123;
      nums[i] = Infinity;
    &#125;
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (
      nums[i] &lt; Infinity &amp;&amp;
      nums[i] &gt; -Infinity &amp;&amp;
      nums[Math.abs(nums[i]) - 1] &gt; 0
    ) &#123;
      nums[Math.abs(nums[i]) - 1] = -nums[Math.abs(nums[i]) - 1];
    &#125;
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (nums[i] &gt; 0) &#123;
      return i + 1;
    &#125;
  &#125;
  return nums.length + 1;
&#125;;
</code></pre>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul>
<li>矩阵置零</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; matrix
 * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) &#123;
  let m = matrix.length;
  let n = matrix[0].length;
  for (let i = 0; i &lt; m; i++) &#123;
    if (matrix[i].includes(0)) &#123;
      for (let j = 0; j &lt; n; j++) &#123;
        if (matrix[i][j] !== 0) &#123;
          matrix[i][j] = &quot;x&quot;;
        &#125; else &#123;
          for (let k = 0; k &lt; m; k++) &#123;
            if (matrix[k][j] !== 0) &#123;
              matrix[k][j] = &quot;x&quot;;
            &#125;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
  for (let i = 0; i &lt; m; i++) &#123;
    for (let j = 0; j &lt; n; j++) &#123;
      if (matrix[i][j] === &quot;x&quot;) &#123;
        matrix[i][j] = 0;
      &#125;
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>旋转图像(先镜像再反转等同于旋转90°)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; matrix
 * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.
 */
var rotate = function (matrix) &#123;
  let n = matrix.length;
  for (let i = 0; i &lt; n; i++) &#123;
    for (let j = i; j &lt; n; j++) &#123;
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    &#125;
  &#125;
  for (let i = 0; i &lt; n; i++) &#123;
    for (let j = 0; j &lt; n / 2; j++) &#123;
      [matrix[i][j], matrix[i][n - 1 - j]] = [
        matrix[i][n - 1 - j],
        matrix[i][j],
      ];
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>搜索二维矩阵(对行进行二分)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; matrix
 * @param &#123;number&#125; target
 * @return &#123;boolean&#125;
 */
var searchMatrix = function (matrix, target) &#123;
  let m = matrix.length;
  let n = matrix[0].length;
  for (let i = 0; i &lt; m; i++) &#123;
    if (matrix[i][0] &lt;= target &amp;&amp; matrix[i][n - 1] &gt;= target) &#123;
      let left = 0;
      let right = n - 1;
      while (left &lt;= right) &#123;
        let mid = Math.floor((left + right) / 2);
        if (matrix[i][mid] === target) &#123;
          return true;
        &#125; else if (matrix[i][mid] &lt; target) &#123;
          left = mid + 1;
        &#125; else &#123;
          right = mid - 1;
        &#125;
      &#125;
    &#125;
  &#125;
  return false;
&#125;;
</code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>相交链表(先记录两个链表的长度)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; headA
 * @param &#123;ListNode&#125; headB
 * @return &#123;ListNode&#125;
 */
var getIntersectionNode = function (headA, headB) &#123;
  let lengthA = 0;
  let lengthB = 0;
  let p1 = headA;
  while (p1) &#123;
    lengthA++;
    p1 = p1.next;
  &#125;
  let p2 = headB;
  while (p2) &#123;
    lengthB++;
    p2 = p2.next;
  &#125;
  if (lengthA &gt; lengthB) &#123;
    [headA, headB] = [headB, headA];
    [lengthA, lengthB] = [lengthB, lengthA];
  &#125;
  let diff = lengthB - lengthA;
  while (diff) &#123;
    headB = headB.next;
    diff--;
  &#125;
  while (headA !== headB) &#123;
    headA = headA.next;
    headB = headB.next;
  &#125;
  return headA;
&#125;;
</code></pre>
<ul>
<li>反转链表(prev current next 一开始current指向头，三个一起移动)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var reverseList = function (head) &#123;
  let prev = null;
  let current = head;
  while (current) &#123;
    let next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  &#125;
  return prev;
&#125;;
</code></pre>
<ul>
<li>回文链表（双指针找到中点，然后把后半部分反转）</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;boolean&#125;
 */
var isPalindrome = function (head) &#123;
  let p1 = head;
  let p2 = head;
  while (p2 &amp;&amp; p2.next) &#123;
    p1 = p1.next;
    p2 = p2.next.next;
  &#125;
  let prev = null;
  let current = p1;
  while (current) &#123;
    let next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  &#125;
  while (prev) &#123;
    if (prev.val !== head.val) return false;
    prev = prev.next;
    head = head.next;
  &#125;
  return true;
&#125;;
</code></pre>
<ul>
<li>环形链表(快慢指针)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; head
 * @return &#123;boolean&#125;
 */
var hasCycle = function (head) &#123;
  let p1 = head;
  let p2 = head;
  while (p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p2) return true;
  &#125;
  return false;
&#125;;
</code></pre>
<ul>
<li>环形链表II(关键是知道当快慢指针相遇时，再有一个指针从头开始走，会和慢指针相遇在pos处)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var detectCycle = function (head) &#123;
  let p1 = head;
  let p2 = head;
  let pos = head;
  while (p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p2) &#123;
      while (pos !== p1) &#123;
        pos = pos.next;
        p1 = p1.next;
      &#125;
      return pos;
    &#125;
  &#125;
  return null;
&#125;;
</code></pre>
<ul>
<li>合并两个有序列表</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; list1
 * @param &#123;ListNode&#125; list2
 * @return &#123;ListNode&#125;
 */
var mergeTwoLists = function (list1, list2) &#123;
  let p1 = list1;
  let p2 = list2;
  let newList = new ListNode(0);
  let head = newList;
  while (p1 &amp;&amp; p2) &#123;
    if (p1.val &lt; p2.val) &#123;
      head.next = p1;
      p1 = p1.next;
    &#125; else &#123;
      head.next = p2;
      p2 = p2.next;
    &#125;
    head = head.next;
  &#125;
  while (p1) &#123;
    head.next = p1;
    p1 = p1.next;
    head = head.next;
  &#125;
  while (p2) &#123;
    head.next = p2;
    p2 = p2.next;
    head = head.next;
  &#125;
  return newList.next;
&#125;;
</code></pre>
<ul>
<li>两数相加</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; l1
 * @param &#123;ListNode&#125; l2
 * @return &#123;ListNode&#125;
 */
var addTwoNumbers = function (l1, l2) &#123;
  let newList = new ListNode(0);
  let head = newList;
  let cnt = 0;
  while (l1 &amp;&amp; l2) &#123;
    let sum = l1.val + l2.val + cnt;
    cnt = Math.floor(sum / 10);
    sum = sum % 10;
    head.next = new ListNode(sum);
    head = head.next;
    l1 = l1.next;
    l2 = l2.next;
  &#125;
  while (l1) &#123;
    let sum = l1.val + cnt;
    cnt = Math.floor(sum / 10);
    sum = sum % 10;
    head.next = new ListNode(sum);
    head = head.next;
    l1 = l1.next;
  &#125;
  while (l2) &#123;
    let sum = l2.val + cnt;
    cnt = Math.floor(sum / 10);
    sum = sum % 10;
    head.next = new ListNode(sum);
    head = head.next;
    l2 = l2.next;
  &#125;
  if (cnt) &#123;
    head.next = new ListNode(cnt);
  &#125;
  return newList.next;
&#125;;
</code></pre>
<ul>
<li>删除链表的倒数第N个节点(双指针，第二个指针先走n步)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @param &#123;number&#125; n
 * @return &#123;ListNode&#125;
 */
var removeNthFromEnd = function (head, n) &#123;
  let p1 = head;
  let p2 = head;
  while (n &gt; 0) &#123;
    p1 = p1.next;
    n--;
  &#125;
  while (p1 &amp;&amp; p1.next) &#123;
    p1 = p1.next;
    p2 = p2.next;
  &#125;
  if (p1) &#123;
    p2.next = p2.next.next;
  &#125; else &#123;
    head = head.next;
  &#125;
  return head;
&#125;;
</code></pre>
<ul>
<li>两两交换链表中的节点(设置一个前驱节点)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var swapPairs = function (head) &#123;
  if (!head || !head.next) return head;
  let newList = new ListNode(0);
  newList.next = head;
  let prev = newList;
  let p1 = head;
  let p2 = head.next;
  while (p1 &amp;&amp; p2) &#123;
    prev.next = p2;
    p1.next = p2.next;
    p2.next = p1;
    prev = p1;
    p1 = p1.next;
    p2 = p1 ? p1.next : null;
  &#125;
  return newList.next;
&#125;;
</code></pre>
<ul>
<li>随机链表的复制（使用递归 题解）</li>
</ul>
<pre><code class="js">var copyRandomList = function(head, cachedNode = new Map()) &#123;
    if (head === null) &#123;
        return null;
    &#125;
    if (!cachedNode.has(head)) &#123;
        cachedNode.set(head, &#123;val: head.val&#125;), Object.assign(cachedNode.get(head), &#123;next: copyRandomList(head.next, cachedNode), random: copyRandomList(head.random, cachedNode)&#125;)
    &#125;
    return cachedNode.get(head);
&#125;
</code></pre>
<ul>
<li>排序链表</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var sortList = function (head) &#123;
  let p1 = head;
  let arr = [];
  while (p1) &#123;
    arr.push(p1.val);
    p1 = p1.next;
  &#125;
  arr.sort((a, b) =&gt; a - b);
  let ans = new ListNode(0);
  let p2 = ans;
  while (arr.length) &#123;
    p2.next = new ListNode(arr.shift());
    p2 = p2.next;
  &#125;
  return ans.next;
&#125;;
</code></pre>
<ul>
<li>LRU缓存（双向链表+哈希表）</li>
</ul>
<pre><code class="js">function ListNode(key, val) &#123;
  this.key = key;
  this.val = val;
  this.next = null;
  this.prev = null;
&#125;

/**
 * @param &#123;number&#125; capacity
 */
var LRUCache = function (capacity) &#123;
  this.capacity = capacity;
  this.cache = new Map();
  this.head = new ListNode(null, null);
  this.tail = new ListNode(null, null);
  this.head.next = this.tail;
  this.tail.prev = this.head;
&#125;;

/**
 * @param &#123;number&#125; key
 * @return &#123;number&#125;
 */
LRUCache.prototype.get = function (key) &#123;
  if (this.cache.has(key)) &#123;
    const node = this.cache.get(key);
    this.moveToFront(node);
    this.cache.set(key, node);
    return node.val;
  &#125; else &#123;
    return -1;
  &#125;
&#125;;

/**
 * @param &#123;number&#125; key
 * @param &#123;number&#125; value
 * @return &#123;void&#125;
 */
LRUCache.prototype.put = function (key, value) &#123;
  if (this.cache.has(key)) &#123;
    const node = this.cache.get(key);
    node.val = value;
    this.moveToFront(node);
    this.cache.set(key, node);
  &#125; else &#123;
    if (this.cache.size === this.capacity) &#123;
      this.cache.delete(this.tail.prev.key);
      this.removeLast();
    &#125;
    const node = new ListNode(key, value);
    this.addToFront(node);
    this.cache.set(key, node);
  &#125;
&#125;;

LRUCache.prototype.addToFront = function (node) &#123;
  node.next = this.head.next;
  this.head.next.prev = node;
  this.head.next = node;
  node.prev = this.head;
&#125;;
LRUCache.prototype.moveToFront = function (node) &#123;
  this.removeNode(node);
  this.addToFront(node);
&#125;;
LRUCache.prototype.removeNode = function (node) &#123;
  node.prev.next = node.next;
  node.next.prev = node.prev;
&#125;;
LRUCache.prototype.removeLast = function () &#123;
  this.removeNode(this.tail.prev);
&#125;;

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
</code></pre>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树的中序遍历</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[]&#125;
 */
var inorderTraversal = function (root) &#123;
  let result = [];
  inOrder(root, result);
  return result;
&#125;;
const inOrder = function (node, result) &#123;
  if (!node) return;
  inOrder(node.left, result);
  result.push(node.val);
  inOrder(node.right, result);
&#125;;
</code></pre>
<ul>
<li>二叉树的最大深度</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number&#125;
 */
var maxDepth = function (root) &#123;
  if (!root) return 0;
  let left = maxDepth(root.left);
  let right = maxDepth(root.right);
  return Math.max(left, right) + 1;
&#125;;
</code></pre>
<ul>
<li>翻转二叉树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;TreeNode&#125;
 */
var invertTree = function (root) &#123;
  if (!root) return null;
  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];
  return root;
&#125;;
</code></pre>
<ul>
<li>对称二叉树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;boolean&#125;
 */
var isSymmetric = function (root) &#123;
  if (!root) return true;
  return isMirror(root.left, root.right);
&#125;;
var isMirror = function (t1, t2) &#123;
  if (!t1 &amp;&amp; !t2) return true;
  if (!t1 || !t2) return false;
  return (
    t1.val === t2.val &amp;&amp;
    isMirror(t1.left, t2.right) &amp;&amp;
    isMirror(t1.right, t2.left)
  );
&#125;;
</code></pre>
<ul>
<li>二叉树的直径（在求深度的过程中维护一个左+右的最大值）</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number&#125;
 */
var diameterOfBinaryTree = function (root) &#123;
  let ans = 0;
  const maxDepth = (root) =&gt; &#123;
    if (!root) return 0;
    let left = maxDepth(root.left);
    let right = maxDepth(root.right);
    ans = Math.max(ans, left + right);
    return Math.max(left, right) + 1;
  &#125;;
  maxDepth(root);
  return ans;
&#125;;
</code></pre>
<ul>
<li>二叉树的层序遍历</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[][]&#125;
 */
var levelOrder = function (root) &#123;
  if (!root) return [];
  let result = [];
  let queue = [root];
  while (queue.length) &#123;
    let currentQueue = [];
    let currentLevel = queue.length;
    for (let i = 0; i &lt; currentLevel; i++) &#123;
      let current = queue.shift();
      currentQueue.push(current.val);
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    &#125;
    result.push(currentQueue);
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>将有序数组转换为二叉搜索树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;number[]&#125; nums
 * @return &#123;TreeNode&#125;
 */
var sortedArrayToBST = function (nums) &#123;
  if (nums.length === 0) return null;
  const mid = Math.floor(nums.length / 2);
  const root = new TreeNode(nums[mid]);
  root.left = sortedArrayToBST(nums.slice(0, mid));
  root.right = sortedArrayToBST(nums.slice(mid + 1));
  return root;
&#125;;
</code></pre>
<ul>
<li>验证二叉搜索树（注意左边所有数字都要小于根）</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;boolean&#125;
 */
var isValidBST = function (root) &#123;
  const helper = (node, min, max) =&gt; &#123;
    if (!node) return true;
    if (node.val &lt;= min || node.val &gt;= max) return false;
    return (
      helper(node.left, min, node.val) &amp;&amp; helper(node.right, node.val, max)
    );
  &#125;;
  return helper(root, -Infinity, Infinity);
&#125;;
</code></pre>
<ul>
<li>二叉搜索树中第K小的元素</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var kthSmallest = function (root, k) &#123;
  let arr = [];
  function inOrder(node) &#123;
    if (!node) return null;
    inOrder(node.left);
    arr.push(node.val);
    inOrder(node.right);
  &#125;
  inOrder(root);
  arr.sort((a, b) =&gt; a - b);
  return arr[k - 1];
&#125;;
</code></pre>
<pre><code class="js">//使用非递归方式进行中序遍历
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var kthSmallest = function (root, k) &#123;
  const stack = [];
  while (root || stack.length) &#123;
    while (root) &#123;
      stack.push(root);
      root = root.left;
    &#125;
    root = stack.pop();
    k--;
    if (k === 0) return root.val;
    root = root.right;
  &#125;
&#125;;
</code></pre>
<ul>
<li>二叉树的右视图(先层次遍历，然后取每一个的最后一位)</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[]&#125;
 */
var rightSideView = function (root) &#123;
  const arr = levelOrder(root);
  let ans = [];
  arr.map((item) =&gt; &#123;
    ans.push(item[item.length - 1]);
  &#125;);
  return ans;
&#125;;

var levelOrder = function (root) &#123;
  if (!root) return [];
  const res = [];
  const queue = [root];
  let currentLevel = [];
  while (queue.length) &#123;
    let length = queue.length;
    for (let i = 0; i &lt; length; i++) &#123;
      let node = queue.shift();
      currentLevel.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    &#125;
    res.push(currentLevel);
    currentLevel = [];
  &#125;
  return res;
&#125;;
</code></pre>
<ul>
<li>二叉树展开为链表（前序的顺序展开为链表，使用递归后序遍历）</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;void&#125; Do not return anything, modify root in-place instead.
 */
var flatten = function (root) &#123;
  let prev = null;
  let preOrder = (node) =&gt; &#123;
    if (!node) return;
    preOrder(node.right);
    preOrder(node.left);
    node.right = prev;
    node.left = null;
    prev = node;
  &#125;;
  preOrder(root);
&#125;;
</code></pre>
<ul>
<li>从前序与中序遍历序列构造二叉树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;number[]&#125; preorder
 * @param &#123;number[]&#125; inorder
 * @return &#123;TreeNode&#125;
 */
var buildTree = function (preorder, inorder) &#123;
  if (preorder.length === 0) return null;
  let mid = inorder.indexOf(preorder[0]);
  let root = new TreeNode(preorder[0]);
  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));
  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));
  return root;
&#125;;
</code></pre>
<ul>
<li>二叉树的最近公共祖先</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val) &#123;
 *     this.val = val;
 *     this.left = this.right = null;
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @param &#123;TreeNode&#125; p
 * @param &#123;TreeNode&#125; q
 * @return &#123;TreeNode&#125;
 */
var lowestCommonAncestor = function (root, p, q) &#123;
  if (!root || root === p || root === q) &#123;
    return root;
  &#125;
  let left = lowestCommonAncestor(root.left, p, q);
  let right = lowestCommonAncestor(root.right, p, q);
  if (!left) return right;
  if (!right) return left;
  return root;
&#125;;
</code></pre>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><ul>
<li>岛屿数量（dfs次数）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;character[][]&#125; grid
 * @return &#123;number&#125;
 */
var numIslands = function (grid) &#123;
  let m = grid.length;
  let n = grid[0].length;
  let count = 0;
  let xx = [-1, 0, 1, 0];
  let yy = [0, 1, 0, -1];
  const dfs = (grid, i, j) =&gt; &#123;
    if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || grid[i][j] !== &quot;1&quot;) &#123;
      return;
    &#125;
    grid[i][j] = &quot;2&quot;;
    for (let k = 0; k &lt; 4; k++) &#123;
      dfs(grid, i + xx[k], j + yy[k]);
    &#125;
  &#125;;
  for (let i = 0; i &lt; m; i++) &#123;
    for (let j = 0; j &lt; n; j++) &#123;
      if (grid[i][j] === &quot;1&quot;) &#123;
        count++;
        dfs(grid, i, j);
      &#125;
    &#125;
  &#125;

  return count;
&#125;;
</code></pre>
<ul>
<li>腐烂的橘子</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; grid
 * @return &#123;number&#125;
 */
var orangesRotting = function (grid) &#123;
  let queue = [];
  let fresh = 0;
  let time = 0;
  let m = grid.length;
  let n = grid[0].length;
  let move = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0],
  ];
  for (let i = 0; i &lt; m; i++) &#123;
    for (let j = 0; j &lt; n; j++) &#123;
      if (grid[i][j] === 2) queue.push([i, j]);
      if (grid[i][j] === 1) fresh++;
    &#125;
  &#125;
  while (queue.length) &#123;
    let size = queue.length;
    for (i = 0; i &lt; size; i++) &#123;
      let [x, y] = queue.shift();
      for (let [dx, dy] of move) &#123;
        let xx = x + dx;
        let yy = y + dy;
        if (xx &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; grid[xx][yy] === 1) &#123;
          grid[xx][yy] = 2;
          fresh--;
          queue.push([xx, yy]);
        &#125;
      &#125;
    &#125;
    time++;
  &#125;
  return fresh ? -1 : Math.max(0, time - 1);
&#125;;
</code></pre>
<ul>
<li>课程表（bfs，记录入度和每个课程的后续课程）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; numCourses
 * @param &#123;number[][]&#125; prerequisites
 * @return &#123;boolean&#125;
 */
var canFinish = function (numCourses, prerequisites) &#123;
  let inDegree = new Array(numCourses).fill(0);
  let map = new Map();
  let count = 0;
  for (let i = 0; i &lt; prerequisites.length; i++) &#123;
    if (map.has(prerequisites[i][1])) &#123;
      map.get(prerequisites[i][1]).push(prerequisites[i][0]);
    &#125; else &#123;
      map.set(prerequisites[i][1], [prerequisites[i][0]]);
    &#125;
    inDegree[prerequisites[i][0]]++;
  &#125;
  let queue = [];
  for (let i = 0; i &lt; numCourses; i++) &#123;
    if (inDegree[i] === 0) &#123;
      queue.push(i);
    &#125;
  &#125;
  while (queue.length) &#123;
    let current = queue.shift();
    count++;
    let children = map.get(current);
    children &amp;&amp;
      children.map((child) =&gt; &#123;
        inDegree[child]--;
        if (inDegree[child] === 0) &#123;
          queue.push(child);
        &#125;
      &#125;);
  &#125;
  return count === numCourses;
&#125;;
</code></pre>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ul>
<li>全排列</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var permute = function (nums) &#123;
  let res = [];
  if (!nums.length) return res;
  const dfs = (path) =&gt; &#123;
    if (path.length === nums.length) &#123;
      res.push(path);
      return;
    &#125;
    for (let i = 0; i &lt; nums.length; i++) &#123;
      if (!path.includes(nums[i])) &#123;
        dfs(path.concat(nums[i]));
      &#125;
    &#125;
  &#125;;
  dfs([]);
  return res;
&#125;;
</code></pre>
<ul>
<li>子集（重做）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var subsets = function (nums) &#123;
  let result = [];
  let dfs = (start, path) =&gt; &#123;
    result.push(path);
    for (let i = start; i &lt; nums.length; i++) &#123;
      dfs(i + 1, [...path, nums[i]]);
    &#125;
  &#125;;
  dfs(0, []);
  return result;
&#125;;
</code></pre>
<ul>
<li>电话号码的字母组合</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; digits
 * @return &#123;string[]&#125;
 */
var letterCombinations = function (digits) &#123;
  if (digits.length === 0) return [];
  let map = &#123;
    2: &quot;abc&quot;,
    3: &quot;def&quot;,
    4: &quot;ghi&quot;,
    5: &quot;jkl&quot;,
    6: &quot;mno&quot;,
    7: &quot;pqrs&quot;,
    8: &quot;tuv&quot;,
    9: &quot;wxyz&quot;,
  &#125;;
  let result = [];

  const dfs = (index, str) =&gt; &#123;
    if (index === digits.length) &#123;
      result.push(str);
      return;
    &#125;
    for (let i = 0; i &lt; map[digits[index]].length; i++) &#123;
      dfs(index + 1, str + map[digits[index]][i]);
    &#125;
  &#125;;
  dfs(0, &quot;&quot;);
  return result;
&#125;;
</code></pre>
<ul>
<li>组合总和（先找数再去重）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; candidates
 * @param &#123;number&#125; target
 * @return &#123;number[][]&#125;
 */
var combinationSum = function (candidates, target) &#123;
  let set = new Set();
  let result = [];
  const dfs = (path, sum) =&gt; &#123;
    if (sum &gt; target) return;
    if (sum === target) &#123;
      path.sort((a, b) =&gt; a - b);
      set.add(JSON.stringify(path));
      return;
    &#125;
    for (let i = 0; i &lt; candidates.length; i++) &#123;
      dfs(path.concat(candidates[i]), sum + candidates[i]);
    &#125;
  &#125;;
  dfs([], 0);
  result = Array.from(set).map((item) =&gt; JSON.parse(item));
  return result;
&#125;;
</code></pre>
<ul>
<li>括号生成(左右括号数量)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; n
 * @return &#123;string[]&#125;
 */
var generateParenthesis = function (n) &#123;
  if (n &lt;= 0) return [];
  let result = [];
  const dfs = (left, right, str) =&gt; &#123;
    if (!left &amp;&amp; !right) &#123;
      result.push(str);
      return;
    &#125;
    if (left === right) &#123;
      dfs(left - 1, right, str + &quot;(&quot;);
    &#125; else if (left &lt; right) &#123;
      if (left &gt; 0) dfs(left - 1, right, str + &quot;(&quot;);
      dfs(left, right - 1, str + &quot;)&quot;);
    &#125;
  &#125;;
  dfs(n, n, &quot;&quot;);
  return result;
&#125;;
</code></pre>
<ul>
<li>单词搜索</li>
</ul>
<pre><code class="js">/**
 * @param &#123;character[][]&#125; board
 * @param &#123;string&#125; word
 * @return &#123;boolean&#125;
 */
var exist = function (board, word) &#123;
  let m = board.length;
  let n = board[0].length;
  let move = [
    [0, 1],
    [1, 0],
    [0, -1],
    [-1, 0],
  ];
  let ans = false;
  let visited = Array(m)
    .fill(0)
    .map(() =&gt; Array(n).fill(false));

  const dfs = (x, y, word) =&gt; &#123;
    if (board[x][y] !== word[0]) return;
    if (word.length === 1) &#123;
      ans = true;
      return;
    &#125;
    visited[x][y] = true;
    for (let i = 0; i &lt; 4; i++) &#123;
      let xx = x + move[i][0];
      let yy = y + move[i][1];
      if (xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &lt; n &amp;&amp; !visited[xx][yy]) &#123;
        dfs(xx, yy, word.substring(1));
        visited[xx][yy] = false;
      &#125;
    &#125;
  &#125;;
  for (let i = 0; i &lt; m; i++) &#123;
    let index = board[i].indexOf(word[0]);
    while (index !== -1 &amp;&amp; !ans) &#123;
      dfs(i, index, word);
      visited[i][index] = false;
      index = board[i].indexOf(word[0], index + 1);
    &#125;
  &#125;
  return ans;
&#125;;
</code></pre>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><ul>
<li>搜索插入位置</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number&#125;
 */
var searchInsert = function (nums, target) &#123;
  let left = 0;
  let right = nums.length - 1;
  while (left &lt;= right) &#123;
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) &#123;
      return mid;
    &#125; else if (nums[mid] &lt; target) &#123;
      left = mid + 1;
    &#125; else &#123;
      right = mid - 1;
    &#125;
  &#125;
  return left;
&#125;;
</code></pre>
<ul>
<li>搜索二维矩阵（二维二分，注意 边界）</li>
</ul>
<pre><code class="JS">/**
 * @param &#123;number[][]&#125; matrix
 * @param &#123;number&#125; target
 * @return &#123;boolean&#125;
 */
var searchMatrix = function (matrix, target) &#123;
  if (matrix.length === 0 || matrix[0].length === 0) &#123;
    return false;
  &#125;
  if (
    target &lt; matrix[0][0] ||
    target &gt; matrix[matrix.length - 1][matrix[0].length - 1]
  )
    return false;
  let m = matrix.length;
  let n = matrix[0].length;

  const getRow = () =&gt; &#123;
    let l = 0;
    let r = m - 1;
    while (l &lt;= r) &#123;
      let mid = Math.floor((l + r) / 2);
      if (matrix[mid][0] &lt;= target &amp;&amp; matrix[mid][n - 1] &gt;= target) &#123;
        return mid;
      &#125; else if (matrix[mid][0] &gt; target) &#123;
        r = mid - 1;
      &#125; else &#123;
        l = mid + 1;
      &#125;
    &#125;
    return l;
  &#125;;
  const row = getRow();
  let l = 0;
  let r = n - 1;
  while (l &lt;= r) &#123;
    let mid = Math.floor((l + r) / 2);
    if (matrix[row][mid] === target) &#123;
      return true;
    &#125; else if (matrix[row][mid] &lt; target) &#123;
      l = mid + 1;
    &#125; else &#123;
      r = mid - 1;
    &#125;
  &#125;
  return matrix[row][l] === target;
&#125;;
</code></pre>
<ul>
<li>在排序数组中查找元素的第一个和最后一个位置(取巧，找target+0.5和-0.5)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
var searchRange = function (nums, target) &#123;
  let target1 = target - 0.5;
  let target2 = target + 0.5;

  const find = (target) =&gt; &#123;
    let l = 0,
      r = nums.length - 1;
    while (l &lt;= r) &#123;
      let mid = Math.floor((l + r) / 2);
      if (nums[mid] &lt; target) &#123;
        l = mid + 1;
      &#125; else &#123;
        r = mid - 1;
      &#125;
    &#125;
    return l;
  &#125;;
  let left = find(target1);
  let right = find(target2);
  if (nums[left] === target &amp;&amp; nums[right - 1] === target) &#123;
    return [left, right - 1];
  &#125; else &#123;
    return [-1, -1];
  &#125;
&#125;;
</code></pre>
<ul>
<li>搜索旋转排序数组</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number&#125;
 */
var search = function (nums, target) &#123;
  let l = 0,
    r = nums.length - 1;
  while (l &lt;= r) &#123;
    let mid = Math.floor((l + r) / 2);
    if (nums[mid] === target) return mid;
    if (nums[l] &lt;= nums[mid]) &#123;
      if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) r = mid - 1;
      else l = mid + 1;
    &#125; else &#123;
      if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + 1;
      else r = mid - 1;
    &#125;
  &#125;
  return -1;
&#125;;
</code></pre>
<ul>
<li>寻找旋转排序数组中的最小值</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var findMin = function (nums) &#123;
  let l = 0;
  let r = nums.length - 1;
  while (l &lt;= r) &#123;
    if (l === r) &#123;
      return nums[l];
    &#125;
    let mid = Math.floor((l + r) / 2);
    if (nums[mid] &lt; nums[r]) &#123;
      r = mid;
    &#125; else &#123;
      l = mid + 1;
    &#125;
  &#125;
  return nums[l];
&#125;;
</code></pre>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>括号匹配</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;boolean&#125;
 */
var isValid = function (s) &#123;
  let stack = [];
  let map = &#123;
    &quot;(&quot;: &quot;)&quot;,
    &quot;&#123;&quot;: &quot;&#125;&quot;,
    &quot;[&quot;: &quot;]&quot;,
  &#125;;
  for (let i = 0; i &lt; s.length; i++) &#123;
    if (s[i] === &quot;(&quot; || s[i] === &quot;&#123;&quot; || s[i] === &quot;[&quot;) &#123;
      stack.push(s[i]);
    &#125; else &#123;
      let last = stack.pop();
      if (s[i] !== map[last]) &#123;
        return false;
      &#125;
    &#125;
  &#125;
  return stack.length === 0;
&#125;;
</code></pre>
<ul>
<li>最小栈</li>
</ul>
<pre><code class="js">var MinStack = function () &#123;
  this.stack = [];
  this.minStack = [];
&#125;;

/**
 * @param &#123;number&#125; val
 * @return &#123;void&#125;
 */
MinStack.prototype.push = function (val) &#123;
  this.stack.push(val);
  if (
    this.minStack.length === 0 ||
    val &lt;= this.minStack[this.minStack.length - 1]
  ) &#123;
    this.minStack.push(val);
  &#125; else &#123;
    this.minStack.push(this.minStack[this.minStack.length - 1]);
  &#125;
&#125;;

/**
 * @return &#123;void&#125;
 */
MinStack.prototype.pop = function () &#123;
  this.stack.pop();
  this.minStack.pop();
&#125;;

/**
 * @return &#123;number&#125;
 */
MinStack.prototype.top = function () &#123;
  return this.stack[this.stack.length - 1];
&#125;;

/**
 * @return &#123;number&#125;
 */
MinStack.prototype.getMin = function () &#123;
  return this.minStack[this.minStack.length - 1];
&#125;;

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
</code></pre>
<ul>
<li>字符串编码</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;string&#125;
 */
var decodeString = function (s) &#123;
  let queue = [];
  let ans = &quot;&quot;;
  for (let i = 0; i &lt; s.length; i++) &#123;
    if (s[i] !== &quot;]&quot;) &#123;
      queue.push(s[i]);
    &#125; else &#123;
      let current = queue.pop();
      let temp = &quot;&quot;;
      let count = 0;
      let times = 0;
      while (current !== &quot;[&quot;) &#123;
        temp = current + temp;
        current = queue.pop();
      &#125;
      while (queue.length &gt; 0 &amp;&amp; !isNaN(queue[queue.length - 1])) &#123;
        count = count + Math.pow(10, times) * parseInt(queue.pop());
        times++;
      &#125;
      queue.push(temp.repeat(count));
    &#125;
  &#125;
  return queue.join(&quot;&quot;);
&#125;;
</code></pre>
<ul>
<li>每日温度</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; temperatures
 * @return &#123;number[]&#125;
 */
var dailyTemperatures = function (temperatures) &#123;
  let ans = new Array(temperatures.length).fill(0);
  let queue = [];
  for (let i = 0; i &lt; temperatures.length; i++) &#123;
    if (!queue.length) &#123;
      queue.push(&#123; index: i, value: temperatures[i] &#125;);
    &#125; else &#123;
      let top = queue[queue.length - 1];
      if (temperatures[i] &lt; top.value) &#123;
        queue.push(&#123; index: i, value: temperatures[i] &#125;);
      &#125; else &#123;
        while (
          queue.length &amp;&amp;
          temperatures[i] &gt; queue[queue.length - 1].value
        ) &#123;
          let top = queue.pop();
          ans[top.index] = i - top.index;
        &#125;
        queue.push(&#123; index: i, value: temperatures[i] &#125;);
      &#125;
    &#125;
  &#125;
  return ans;
&#125;;
</code></pre>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul>
<li>买卖股票的最佳时机</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; prices
 * @return &#123;number&#125;
 */
var maxProfit = function(prices) &#123;
    let min = Infinity;
    let max = 0;
    for(let i=0;i&lt;prices.length;i++)&#123;
        if(prices[i]&lt;min)&#123;
            min = prices[i];
        &#125;
        max = Math.max(max,prices[i]-min);
    &#125;
    return max;
&#125;;
</code></pre>
<ul>
<li>跳跃游戏（倒序遍历）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;boolean&#125;
 */
var canJump = function(nums) &#123;
    if(nums.length&lt;=1) return true;
    let len = 1;
    for(let i = nums.length-2;i&gt;0;i--)&#123;
        if(nums[i]&gt;=len)&#123;
            len = 1;
        &#125;else&#123;
            len++;
        &#125;
    &#125;
    if(nums[0]&gt;=len) return true;
    return false;
&#125;;
</code></pre>
<ul>
<li>跳跃游戏II</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var jump = function(nums) &#123;
    let ans = 0;
    let maxPos = 0;
    let end = 0;
    for(let i=0;i&lt;nums.length-1;i++)&#123;
        maxPos = Math.max(maxPos,i+nums[i]);
        if(end===i)&#123;
            end = maxPos; 
            ans++;
        &#125;
    &#125;
    return ans;
&#125;;
</code></pre>
<ul>
<li>划分字母区间</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;number[]&#125;
 */
var partitionLabels = function(s) &#123;
    let start = 0;
    let end = 0;
    let ans = [];
    let last = [];
    for(let i = 0;i&lt;s.length;i++)&#123;
        last[s[i]] = i;
    &#125;
    for(let i=0;i&lt;s.length;i++)&#123;
        end = Math.max(end,last[s[i]]);
        if(i===end)&#123;
            ans.push(end-start+1);
            start = end+1;
        &#125;
    &#125;
    return ans;
&#125;;
</code></pre>
<ul>
<li>爬楼梯</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function (n) &#123;
  let dp = new Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i &lt;= n; i++) &#123;
    dp[i] = dp[i - 1] + dp[i - 2];
  &#125;
  return dp[n];
&#125;;
</code></pre>
<ul>
<li>杨辉三角</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; numRows
 * @return &#123;number[][]&#125;
 */
var generate = function (numRows) &#123;
  const result = [];
  for (let i = 0; i &lt; numRows; i++) &#123;
    const row = [];
    for (let j = 0; j &lt;= i; j++) &#123;
      if (j === 0 || j === i) &#123;
        row.push(1);
      &#125; else &#123;
        row.push(result[i - 1][j - 1] + result[i - 1][j]);
      &#125;
    &#125;
    result.push(row);
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>打家劫舍</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var rob = function (nums) &#123;
  if (nums.length &lt; 2) &#123;
    return nums[0];
  &#125;
  let dp = new Array(nums.length).fill(0);
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  for (let i = 2; i &lt; nums.length; i++) &#123;
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  &#125;
  return dp[nums.length - 1];
&#125;;
</code></pre>
<ul>
<li>完全平方数</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var numSquares = function (n) &#123;
  let dp = new Array(n + 1).fill(0);
  for (let i = 1; i &lt;= n; i++) &#123;
    let min = Infinity;
    for (let j = 1; j * j &lt;= i; j++) &#123;
      min = Math.min(min, dp[i - j * j]);
    &#125;
    dp[i] = min + 1;
  &#125;
  return dp[n];
&#125;;
</code></pre>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul>
<li>只出现一次的数字</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var singleNumber = function (nums) &#123;
  let ans = nums[0];
  for (let i = 1; i &lt; nums.length; i++) &#123;
    ans ^= nums[i];
  &#125;
  return ans;
&#125;;
</code></pre>
<ul>
<li>多数元素</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var majorityElement = function(nums) &#123;
    let ans = 0;
    let count = 0;
    for(let i=0;i&lt;nums.length;i++)&#123;
        if(count===0)&#123;
            ans = nums[i];
        &#125;
        if(ans===nums[i])&#123;
            count++;
        &#125;else&#123;
            count--;
        &#125;
    &#125;
    return ans;
&#125;;
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/算法" style=color:#00a596>
                算法
            </a>
        </span>
        
    </div>

    <a href="/LeetCode-Hot100/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/自动生成接口文档/">
        <h2>
            自动生成接口文档
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/9
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>每当项目即将验收时，都需要写一份详细的接口文档，太累啦！那么，既然已经有了现成的yaml文件，能不能让程序帮我们写呢？答案是可以！</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/工具类" style=color:#ff7d73>
                工具类
            </a>
        </span>
        
    </div>

    <a href="/自动生成接口文档/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/gitlab提交代码自动部署（前端）/">
        <h2>
            gitlab ci/cd 自动部署项目（前端）
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/5/27
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>项目部署完毕后，若要对项目进行修改，须重新对项目进行打包、将打包后的文件上传到服务器、刷新nginx，比较繁琐，gitlab ci/cd可以将流程自动化，我们只需将修改后的代码推到gitlab上便自动部署。</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/项目部署" style=color:#ff7d73>
                项目部署
            </a>
        </span>
        
    </div>

    <a href="/gitlab提交代码自动部署（前端）/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/将nginx设置为服务并开机启动/">
        <h2>
            将nginx设置为服务并开机启动
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/5/26
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>在项目部署之后，难免会遇到虚拟机重启的情况，虚拟机重启后要重启nginx服务，比较麻烦，那么将nginx设置为系统服务并开机启动即可。</p>
<ul>
<li>下载winsw包，地址：<a target="_blank" rel="noopener" href="https://github.com/winsw/winsw/releases">https://github.com/winsw/winsw/releases</a></li>
</ul>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/项目部署" style=color:#03a9f4>
                项目部署
            </a>
        </span>
        
    </div>

    <a href="/将nginx设置为服务并开机启动/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/Webpack/">
        <h2>
            Webpack
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/4/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h4 id="什么是Webpack"><a href="#什么是Webpack" class="headerlink" title="什么是Webpack"></a>什么是Webpack</h4><p>Webpack是一个现代化的打包工具，它能够将前端项目中的各种资源，如JS、CSS、图片等，打包成一个或多个静态文件。Webpack最初是用于打包JavaScript模块，但是他也可以用于处理其他类型的资源。</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#ffa2c4>
                前端
            </a>
        </span>
        
    </div>

    <a href="/Webpack/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/手写发布订阅/">
        <h2>
            手写发布订阅
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/4/1
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>发布订阅是一种常见的设计模式，也成为观察者模式。它基于事件处理机制，允许多个观察者订阅某个事件，当时间被触发时，所有订阅该事件的观察者都会收到通知。</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#00bcd4>
                前端
            </a>
        </span>
        
    </div>

    <a href="/手写发布订阅/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/BFC_IFC_GFC_FFC/">
        <h2>
            BFC_IFC_GFC_FFC
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/3/13
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h4 id="FC"><a href="#FC" class="headerlink" title="FC"></a>FC</h4><p>FC(Formatting Contexts，格式化上下文)，他是W3C规范中的一个概念。简单来说，它是页面中的一块渲染区域，并且拥有自己的一套渲染规则，它决定了子元素如何定位，以及和其他元素的关系和相互作用，他并不会影响区域外的元素。</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#ff7d73>
                前端
            </a>
        </span>
        
    </div>

    <a href="/BFC_IFC_GFC_FFC/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/闭包/">
        <h2>
            闭包
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/3/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>闭包是一种特殊的对象/特殊的机制。</p>
<p>闭包由两部分组成：执行上下文(A)和在该执行上下文中创建的函数(B)；</p>
<p>当B执行时访问了A中变量对象中的值，就产生了闭包；</p>
<p>另一个解释：闭包是一项技术或者一个特性，函数作用域中的变量在函数执行完之后就会被垃圾回收，一般情况下访问一个函数作用域中的变量是无法访问的，只能通过特殊的技术或者特性来实现，就是在函数作用域中创建内部函数来实现，这样就不会使得函数执行完成变量被回收，这种技术或特性被称为闭包。像是把变量包裹了起来，形象的称为闭包。</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#ffa2c4>
                前端
            </a>
        </span>
        
    </div>

    <a href="/闭包/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/BFC/">
        <h2>
            BFC
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/3/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            <h4 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h4><p>BFC(Block Formatting Context，块级格式化上下文)，一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素，BFC是是一块独立的渲染区域，可以将BFC看成是元素的一种属性，拥有了这种属性的元素就会使它的子元素与世隔绝，不会影响到外部其他元素。</p>
            
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/前端" style=color:#00bcd4>
                前端
            </a>
        </span>
        
    </div>

    <a href="/BFC/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            

            
            <span class="page-omit">...</span>
            <a href="/page/4">
                <span class="page-num">
                    4
                </span>
            </a>
            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="/images/avatar.jpg " alt="头像">
        </div>
        <div class="name">
            Like Frost
        </div>
        <div class="descriptions">
            
            <div class="description">
                热爱可抵岁月漫长
            </div>
            
            <div class="description">
                rp++
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/LikeFrost">

                    
                    <a-icon type="github"
                        theme="outlined" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/like-frost">

                    
                    <a-icon type="zhihu"
                        theme="outlined" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/like-frost">
                    friend1
                </a>
            </div>
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/like-frost">
                    friend2
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2021 - 2024 摸鱼日志
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Like Frost
        </div>
        <div></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>