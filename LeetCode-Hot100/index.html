
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>摸鱼日志 || LeetCode Hot100</title>
    <meta name="author" content="Like Frost">
    <meta name="description" content="吾生也有涯，而知也无涯 ">
    <meta name="keywords" content="编程,coding,个人博客 ">
    <link rel="icon" href="/images/avatar.jpg">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">摸鱼日志</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="outlined" />
            </span>
            <span>首页</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="outlined" />
            </span>
            <span>标签</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="ordered-list" theme="outlined" />
            </span>
            <span>归档</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>摸鱼日志</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="outlined" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">首页</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="outlined" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">标签</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="ordered-list" theme="outlined" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">归档</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                     
<link rel="stylesheet" href="/css/post-body.css">
<div class="article">
    <div>
        <h1>LeetCode Hot100 </h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2024/2/26
        </span>

        

        

        <span class="tags">
            <span class="icon">
                <a-icon type="tags" theme="filled" />
            </span>
            
            <span class="tag">
                
                <a href="/tags/算法" style=color:#ff7d73>
                    算法
                </a>
            </span>
            
        </span>
        
    </div>

    <div class="content" v-pre>
        <span id="more"></span>

<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><ul>
<li>两数之和</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
var twoSum = function (nums, target) &#123;
  let map = new Map();
  for (let i = 0; i &lt; nums.length; i++) &#123;
    map.set(nums[i], i);
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (map.has(target - nums[i]) &amp;&amp; map.get(target - nums[i]) !== i) &#123;
      return [i, map.get(target - nums[i])];
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>字母异位词</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string[]&#125; strs
 * @return &#123;string[][]&#125;
 */
var groupAnagrams = function (strs) &#123;
  let map = new Map();
  for (let str of strs) &#123;
    if (map.has(str.split(&quot;&quot;).sort().join(&quot;&quot;))) &#123;
      map.get(str.split(&quot;&quot;).sort().join(&quot;&quot;)).push(str);
    &#125; else &#123;
      map.set(str.split(&quot;&quot;).sort().join(&quot;&quot;), [str]);
    &#125;
  &#125;
  return Array.from(map.values());
&#125;;
</code></pre>
<ul>
<li>最长连续序列(使用set和动态规划)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var longestConsecutive = function (nums) &#123;
  let set = new Set(nums);
  let result = 0;
  for (let num of nums) &#123;
    if (!set.has(num - 1)) &#123;
      let current = num;
      let count = 1;
      while (set.has(current + 1)) &#123;
        current++;
        count++;
      &#125;
      result = Math.max(result, count);
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var longestConsecutive = function (nums) &#123;
  if (nums.length == 0) &#123;
    return 0;
  &#125;
  let dp = [];
  let result = 1;
  dp[0] = 1;
  nums.sort((a, b) =&gt; a - b);
  for (let i = 1; i &lt; nums.length; i++) &#123;
    dp[i] = 1;
    if (nums[i] == nums[i - 1]) &#123;
      dp[i] = dp[i - 1];
    &#125;
    if (nums[i] == nums[i - 1] + 1) &#123;
      dp[i] = dp[i - 1] + 1;
    &#125;
    result = Math.max(result, dp[i]);
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><ul>
<li>移动零</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;void&#125; Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) &#123;
  let a = 0;
  let b = 0;
  while (a &lt; nums.length) &#123;
    if (nums[a] !== 0) &#123;
      nums[b] = nums[a];
      b++;
    &#125;
    a++;
  &#125;
  while (b &lt; nums.length) &#123;
    nums[b] = 0;
    b++;
  &#125;
&#125;;
</code></pre>
<ul>
<li>盛最多水的容器(从两端往中间移动短板，因为多少水是由短板决定的，移动长板并不能改善)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; height
 * @return &#123;number&#125;
 */
var maxArea = function (height) &#123;
  let result = 0;
  let left = 0;
  let right = height.length - 1;
  while (left &lt; right) &#123;
    result = Math.max(
      result,
      (right - left) * Math.min(height[left], height[right])
    );
    if (height[left] &lt; height[right]) &#123;
      left++;
    &#125; else &#123;
      right--;
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>三数之和</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var threeSum = function (nums) &#123;
  let result = [];
  nums.sort((a, b) =&gt; a - b);
  for (let i = 0; i &lt; nums.length - 2; i++) &#123;
    if (i === 0 || nums[i] !== nums[i - 1]) &#123;
      let sum = 0 - nums[i];
      let left = i + 1;
      let right = nums.length - 1;
      while (left &lt; right) &#123;
        if (nums[left] + nums[right] === sum) &#123;
          result.push([nums[i], nums[left], nums[right]]);
          left++;
          right--;
          while (left &lt; right &amp;&amp; nums[left] === nums[left - 1]) left++; // 跳过重复元素
          while (left &lt; right &amp;&amp; nums[right] === nums[right + 1]) right--; // 跳过重复元素
        &#125; else if (nums[left] + nums[right] &lt; sum) &#123;
          left++;
        &#125; else &#123;
          right--;
        &#125;
      &#125;
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>接雨水(双指针，类似于打擂，永远是强者在台上)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; height
 * @return &#123;number&#125;
 */
var trap = function (height) &#123;
  let left = 0;
  let right = height.length - 1;
  let leftMax = 0;
  let rightMax = 0;
  let result = 0;
  while (left &lt; right) &#123;
    if (height[left] &lt; height[right]) &#123;
      if (height[left] &gt;= leftMax) &#123;
        leftMax = height[left];
      &#125; else &#123;
        result += leftMax - height[left];
      &#125;
      left++;
    &#125; else &#123;
      if (height[right] &gt;= rightMax) &#123;
        rightMax = height[right];
      &#125; else &#123;
        result += rightMax - height[right];
      &#125;
      right--;
    &#125;
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ul>
<li>无重复字符的最长字串</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;number&#125;
 */
var lengthOfLongestSubstring = function (s) &#123;
  let max = 0;
  let start = 0;
  let map = new Map();
  for (let i = 0; i &lt; s.length; i++) &#123;
    if (map.has(s[i])) &#123;
      start = Math.max(start, map.get(s[i]) + 1);
    &#125;
    max = Math.max(max, i - start + 1);
    map.set(s[i], i);
  &#125;
  return max;
&#125;;
</code></pre>
<ul>
<li>找到字符串中所有的字母异位词</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @param &#123;string&#125; p
 * @return &#123;number[]&#125;
 */
var findAnagrams = function (s, p) &#123;
  if (s.length &lt; p.length) return [];
  let result = [];
  let pMap = new Array(26).fill(0);
  let sMap = new Array(26).fill(0);
  for (let i = 0; i &lt; p.length; i++) &#123;
    sMap[s.charCodeAt(i) - 97]++;
    pMap[p.charCodeAt(i) - 97]++;
  &#125;
  for (let i = 0; i &lt;= s.length - p.length; i++) &#123;
    if (sMap.join(&quot;&quot;) === pMap.join(&quot;&quot;)) result.push(i);
    sMap[s.charCodeAt(i) - 97]--;
    sMap[s.charCodeAt(i + p.length) - 97]++;
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><ul>
<li>和为k的子数组(前缀和优化)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var subarraySum = function (nums, k) &#123;
  let result = 0;
  let sum = 0;
  let map = new Map();
  map.set(0, 1);
  for (let i = 0; i &lt; nums.length; i++) &#123;
    sum += nums[i];
    result += map.get(sum - k) || 0;
    map.set(sum, (map.get(sum) || 0) + 1);
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>滑动窗口最大值(单调队列-双端队列)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;number[]&#125;
 */
var maxSlidingWindow = function (nums, k) &#123;
  const q = [];
  const result = [];
  for (let i = 0; i &lt; k; i++) &#123;
    while (q.length &amp;&amp; nums[q[q.length - 1]] &lt;= nums[i]) &#123;
      q.pop();
    &#125;
    q.push(i);
  &#125;
  result.push(nums[q[0]]);

  for (let i = k; i &lt; nums.length; i++) &#123;
    while (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - 1]]) &#123;
      q.pop();
    &#125;
    q.push(i);
    while (q[0] &lt;= i - k) &#123;
      q.shift();
    &#125;
    result.push(nums[q[0]]);
  &#125;
  return result;
&#125;;
</code></pre>
<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><ul>
<li>最大子数组和(类似于dp，当和小于0的时候就丢弃)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var maxSubArray = function (nums) &#123;
  let max = nums[0];
  let sum = 0;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (sum &lt; 0) &#123;
      sum = 0;
    &#125;
    sum += nums[i];
    max = Math.max(max, sum);
  &#125;
  return max;
&#125;;
</code></pre>
<ul>
<li>合并区间（排序）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; intervals
 * @return &#123;number[][]&#125;
 */
var merge = function (intervals) &#123;
  intervals.sort((a, b) =&gt; a[0] - b[0]);
  for (let i = 0; i &lt; intervals.length - 1; i++) &#123;
    if (intervals[i][1] &gt;= intervals[i + 1][0]) &#123;
      intervals[i][1] = Math.max(intervals[i][1], intervals[i + 1][1]);
      intervals.splice(i + 1, 1);
      i--;
    &#125;
  &#125;
  return intervals;
&#125;;
</code></pre>
<ul>
<li>轮转数组(注意处理k大于数组长度的情况)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; k
 * @return &#123;void&#125; Do not return anything, modify nums in-place instead.
 */
var rotate = function (nums, k) &#123;
  k = k % nums.length;
  nums.unshift(...nums.slice(nums.length - k));
  nums.splice(nums.length - k, k);
&#125;;
</code></pre>
<ul>
<li>除自身以外数组的乘积(前缀乘积和后缀乘积)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[]&#125;
 */
var productExceptSelf = function (nums) &#123;
  let pre = new Array(nums.length).fill(1);
  let post = new Array(nums.length).fill(1);
  let result = [];
  pre[0] = nums[0];
  for (let i = 1; i &lt; nums.length; i++) &#123;
    pre[i] = pre[i - 1] * nums[i];
  &#125;
  post[nums.length - 1] = nums[nums.length - 1];
  for (let i = nums.length - 2; i &gt;= 0; i--) &#123;
    post[i] = post[i + 1] * nums[i];
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    result.push(
      i === 0
        ? post[i + 1]
        : i === nums.length - 1
        ? pre[i - 1]
        : pre[i - 1] * post[i + 1]
    );
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>空间复杂度为o(1) ，利用输出数组作为后缀乘积</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[]&#125;
 */
var productExceptSelf = function (nums) &#123;
  let post = new Array(nums.length).fill(1);
  post[nums.length - 1] = nums[nums.length - 1];
  for (let i = nums.length - 2; i &gt;= 0; i--) &#123;
    post[i] = post[i + 1] * nums[i];
  &#125;
  let pre = 1;
  for (let i = 0; i &lt; nums.length - 1; i++) &#123;
    post[i] = post[i + 1] * pre;
    pre *= nums[i];
  &#125;
  post[nums.length - 1] = pre;
  return post;
&#125;;
</code></pre>
<ul>
<li>缺失的第一个正数(将现有数组想办法当成hash表)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var firstMissingPositive = function (nums) &#123;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (nums[i] &lt; 1 || nums[i] &gt; nums.length) &#123;
      nums[i] = Infinity;
    &#125;
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (
      nums[i] &lt; Infinity &amp;&amp;
      nums[i] &gt; -Infinity &amp;&amp;
      nums[Math.abs(nums[i]) - 1] &gt; 0
    ) &#123;
      nums[Math.abs(nums[i]) - 1] = -nums[Math.abs(nums[i]) - 1];
    &#125;
  &#125;
  for (let i = 0; i &lt; nums.length; i++) &#123;
    if (nums[i] &gt; 0) &#123;
      return i + 1;
    &#125;
  &#125;
  return nums.length + 1;
&#125;;
</code></pre>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><ul>
<li>矩阵置零</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; matrix
 * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.
 */
var setZeroes = function (matrix) &#123;
  let m = matrix.length;
  let n = matrix[0].length;
  for (let i = 0; i &lt; m; i++) &#123;
    if (matrix[i].includes(0)) &#123;
      for (let j = 0; j &lt; n; j++) &#123;
        if (matrix[i][j] !== 0) &#123;
          matrix[i][j] = &quot;x&quot;;
        &#125; else &#123;
          for (let k = 0; k &lt; m; k++) &#123;
            if (matrix[k][j] !== 0) &#123;
              matrix[k][j] = &quot;x&quot;;
            &#125;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;
  for (let i = 0; i &lt; m; i++) &#123;
    for (let j = 0; j &lt; n; j++) &#123;
      if (matrix[i][j] === &quot;x&quot;) &#123;
        matrix[i][j] = 0;
      &#125;
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>旋转图像(先镜像再反转等同于旋转90°)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; matrix
 * @return &#123;void&#125; Do not return anything, modify matrix in-place instead.
 */
var rotate = function (matrix) &#123;
  let n = matrix.length;
  for (let i = 0; i &lt; n; i++) &#123;
    for (let j = i; j &lt; n; j++) &#123;
      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
    &#125;
  &#125;
  for (let i = 0; i &lt; n; i++) &#123;
    for (let j = 0; j &lt; n / 2; j++) &#123;
      [matrix[i][j], matrix[i][n - 1 - j]] = [
        matrix[i][n - 1 - j],
        matrix[i][j],
      ];
    &#125;
  &#125;
&#125;;
</code></pre>
<ul>
<li>搜索二维矩阵(对行进行二分)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; matrix
 * @param &#123;number&#125; target
 * @return &#123;boolean&#125;
 */
var searchMatrix = function (matrix, target) &#123;
  let m = matrix.length;
  let n = matrix[0].length;
  for (let i = 0; i &lt; m; i++) &#123;
    if (matrix[i][0] &lt;= target &amp;&amp; matrix[i][n - 1] &gt;= target) &#123;
      let left = 0;
      let right = n - 1;
      while (left &lt;= right) &#123;
        let mid = Math.floor((left + right) / 2);
        if (matrix[i][mid] === target) &#123;
          return true;
        &#125; else if (matrix[i][mid] &lt; target) &#123;
          left = mid + 1;
        &#125; else &#123;
          right = mid - 1;
        &#125;
      &#125;
    &#125;
  &#125;
  return false;
&#125;;
</code></pre>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>相交链表(先记录两个链表的长度)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; headA
 * @param &#123;ListNode&#125; headB
 * @return &#123;ListNode&#125;
 */
var getIntersectionNode = function (headA, headB) &#123;
  let lengthA = 0;
  let lengthB = 0;
  let p1 = headA;
  while (p1) &#123;
    lengthA++;
    p1 = p1.next;
  &#125;
  let p2 = headB;
  while (p2) &#123;
    lengthB++;
    p2 = p2.next;
  &#125;
  if (lengthA &gt; lengthB) &#123;
    [headA, headB] = [headB, headA];
    [lengthA, lengthB] = [lengthB, lengthA];
  &#125;
  let diff = lengthB - lengthA;
  while (diff) &#123;
    headB = headB.next;
    diff--;
  &#125;
  while (headA !== headB) &#123;
    headA = headA.next;
    headB = headB.next;
  &#125;
  return headA;
&#125;;
</code></pre>
<ul>
<li>反转链表(prev current next 一开始current指向头，三个一起移动)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var reverseList = function (head) &#123;
  let prev = null;
  let current = head;
  while (current) &#123;
    let next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  &#125;
  return prev;
&#125;;
</code></pre>
<ul>
<li>回文链表（双指针找到中点，然后把后半部分反转）</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;boolean&#125;
 */
var isPalindrome = function (head) &#123;
  let p1 = head;
  let p2 = head;
  while (p2 &amp;&amp; p2.next) &#123;
    p1 = p1.next;
    p2 = p2.next.next;
  &#125;
  let prev = null;
  let current = p1;
  while (current) &#123;
    let next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  &#125;
  while (prev) &#123;
    if (prev.val !== head.val) return false;
    prev = prev.next;
    head = head.next;
  &#125;
  return true;
&#125;;
</code></pre>
<ul>
<li>环形链表(快慢指针)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; head
 * @return &#123;boolean&#125;
 */
var hasCycle = function (head) &#123;
  let p1 = head;
  let p2 = head;
  while (p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p2) return true;
  &#125;
  return false;
&#125;;
</code></pre>
<ul>
<li>环形链表II(关键是知道当快慢指针相遇时，再有一个指针从头开始走，会和慢指针相遇在pos处)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val) &#123;
 *     this.val = val;
 *     this.next = null;
 * &#125;
 */

/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var detectCycle = function (head) &#123;
  let p1 = head;
  let p2 = head;
  let pos = head;
  while (p1 &amp;&amp; p2 &amp;&amp; p2.next) &#123;
    p1 = p1.next;
    p2 = p2.next.next;
    if (p1 === p2) &#123;
      while (pos !== p1) &#123;
        pos = pos.next;
        p1 = p1.next;
      &#125;
      return pos;
    &#125;
  &#125;
  return null;
&#125;;
</code></pre>
<ul>
<li>合并两个有序列表</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; list1
 * @param &#123;ListNode&#125; list2
 * @return &#123;ListNode&#125;
 */
var mergeTwoLists = function (list1, list2) &#123;
  let p1 = list1;
  let p2 = list2;
  let newList = new ListNode(0);
  let head = newList;
  while (p1 &amp;&amp; p2) &#123;
    if (p1.val &lt; p2.val) &#123;
      head.next = p1;
      p1 = p1.next;
    &#125; else &#123;
      head.next = p2;
      p2 = p2.next;
    &#125;
    head = head.next;
  &#125;
  while (p1) &#123;
    head.next = p1;
    p1 = p1.next;
    head = head.next;
  &#125;
  while (p2) &#123;
    head.next = p2;
    p2 = p2.next;
    head = head.next;
  &#125;
  return newList.next;
&#125;;
</code></pre>
<ul>
<li>两数相加</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; l1
 * @param &#123;ListNode&#125; l2
 * @return &#123;ListNode&#125;
 */
var addTwoNumbers = function (l1, l2) &#123;
  let newList = new ListNode(0);
  let head = newList;
  let cnt = 0;
  while (l1 &amp;&amp; l2) &#123;
    let sum = l1.val + l2.val + cnt;
    cnt = Math.floor(sum / 10);
    sum = sum % 10;
    head.next = new ListNode(sum);
    head = head.next;
    l1 = l1.next;
    l2 = l2.next;
  &#125;
  while (l1) &#123;
    let sum = l1.val + cnt;
    cnt = Math.floor(sum / 10);
    sum = sum % 10;
    head.next = new ListNode(sum);
    head = head.next;
    l1 = l1.next;
  &#125;
  while (l2) &#123;
    let sum = l2.val + cnt;
    cnt = Math.floor(sum / 10);
    sum = sum % 10;
    head.next = new ListNode(sum);
    head = head.next;
    l2 = l2.next;
  &#125;
  if (cnt) &#123;
    head.next = new ListNode(cnt);
  &#125;
  return newList.next;
&#125;;
</code></pre>
<ul>
<li>删除链表的倒数第N个节点(双指针，第二个指针先走n步)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @param &#123;number&#125; n
 * @return &#123;ListNode&#125;
 */
var removeNthFromEnd = function (head, n) &#123;
  let p1 = head;
  let p2 = head;
  while (n &gt; 0) &#123;
    p1 = p1.next;
    n--;
  &#125;
  while (p1 &amp;&amp; p1.next) &#123;
    p1 = p1.next;
    p2 = p2.next;
  &#125;
  if (p1) &#123;
    p2.next = p2.next.next;
  &#125; else &#123;
    head = head.next;
  &#125;
  return head;
&#125;;
</code></pre>
<ul>
<li>两两交换链表中的节点(设置一个前驱节点)</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var swapPairs = function (head) &#123;
  if (!head || !head.next) return head;
  let newList = new ListNode(0);
  newList.next = head;
  let prev = newList;
  let p1 = head;
  let p2 = head.next;
  while (p1 &amp;&amp; p2) &#123;
    prev.next = p2;
    p1.next = p2.next;
    p2.next = p1;
    prev = p1;
    p1 = p1.next;
    p2 = p1 ? p1.next : null;
  &#125;
  return newList.next;
&#125;;
</code></pre>
<ul>
<li>随机链表的复制（使用递归 题解）</li>
</ul>
<pre><code class="js">var copyRandomList = function(head, cachedNode = new Map()) &#123;
    if (head === null) &#123;
        return null;
    &#125;
    if (!cachedNode.has(head)) &#123;
        cachedNode.set(head, &#123;val: head.val&#125;), Object.assign(cachedNode.get(head), &#123;next: copyRandomList(head.next, cachedNode), random: copyRandomList(head.random, cachedNode)&#125;)
    &#125;
    return cachedNode.get(head);
&#125;
</code></pre>
<ul>
<li>排序链表</li>
</ul>
<pre><code class="js">/**
 * Definition for singly-linked list.
 * function ListNode(val, next) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * &#125;
 */
/**
 * @param &#123;ListNode&#125; head
 * @return &#123;ListNode&#125;
 */
var sortList = function (head) &#123;
  let p1 = head;
  let arr = [];
  while (p1) &#123;
    arr.push(p1.val);
    p1 = p1.next;
  &#125;
  arr.sort((a, b) =&gt; a - b);
  let ans = new ListNode(0);
  let p2 = ans;
  while (arr.length) &#123;
    p2.next = new ListNode(arr.shift());
    p2 = p2.next;
  &#125;
  return ans.next;
&#125;;
</code></pre>
<ul>
<li>LRU缓存（双向链表+哈希表）</li>
</ul>
<pre><code class="js">function ListNode(key, val) &#123;
  this.key = key;
  this.val = val;
  this.next = null;
  this.prev = null;
&#125;

/**
 * @param &#123;number&#125; capacity
 */
var LRUCache = function (capacity) &#123;
  this.capacity = capacity;
  this.cache = new Map();
  this.head = new ListNode(null, null);
  this.tail = new ListNode(null, null);
  this.head.next = this.tail;
  this.tail.prev = this.head;
&#125;;

/**
 * @param &#123;number&#125; key
 * @return &#123;number&#125;
 */
LRUCache.prototype.get = function (key) &#123;
  if (this.cache.has(key)) &#123;
    const node = this.cache.get(key);
    this.moveToFront(node);
    this.cache.set(key, node);
    return node.val;
  &#125; else &#123;
    return -1;
  &#125;
&#125;;

/**
 * @param &#123;number&#125; key
 * @param &#123;number&#125; value
 * @return &#123;void&#125;
 */
LRUCache.prototype.put = function (key, value) &#123;
  if (this.cache.has(key)) &#123;
    const node = this.cache.get(key);
    node.val = value;
    this.moveToFront(node);
    this.cache.set(key, node);
  &#125; else &#123;
    if (this.cache.size === this.capacity) &#123;
      this.cache.delete(this.tail.prev.key);
      this.removeLast();
    &#125;
    const node = new ListNode(key, value);
    this.addToFront(node);
    this.cache.set(key, node);
  &#125;
&#125;;

LRUCache.prototype.addToFront = function (node) &#123;
  node.next = this.head.next;
  this.head.next.prev = node;
  this.head.next = node;
  node.prev = this.head;
&#125;;
LRUCache.prototype.moveToFront = function (node) &#123;
  this.removeNode(node);
  this.addToFront(node);
&#125;;
LRUCache.prototype.removeNode = function (node) &#123;
  node.prev.next = node.next;
  node.next.prev = node.prev;
&#125;;
LRUCache.prototype.removeLast = function () &#123;
  this.removeNode(this.tail.prev);
&#125;;

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
</code></pre>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树的中序遍历</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[]&#125;
 */
var inorderTraversal = function (root) &#123;
  let result = [];
  inOrder(root, result);
  return result;
&#125;;
const inOrder = function (node, result) &#123;
  if (!node) return;
  inOrder(node.left, result);
  result.push(node.val);
  inOrder(node.right, result);
&#125;;
</code></pre>
<ul>
<li>二叉树的最大深度</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number&#125;
 */
var maxDepth = function (root) &#123;
  if (!root) return 0;
  let left = maxDepth(root.left);
  let right = maxDepth(root.right);
  return Math.max(left, right) + 1;
&#125;;
</code></pre>
<ul>
<li>翻转二叉树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;TreeNode&#125;
 */
var invertTree = function (root) &#123;
  if (!root) return null;
  [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];
  return root;
&#125;;
</code></pre>
<ul>
<li>对称二叉树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;boolean&#125;
 */
var isSymmetric = function (root) &#123;
  if (!root) return true;
  return isMirror(root.left, root.right);
&#125;;
var isMirror = function (t1, t2) &#123;
  if (!t1 &amp;&amp; !t2) return true;
  if (!t1 || !t2) return false;
  return (
    t1.val === t2.val &amp;&amp;
    isMirror(t1.left, t2.right) &amp;&amp;
    isMirror(t1.right, t2.left)
  );
&#125;;
</code></pre>
<ul>
<li>二叉树的直径（在求深度的过程中维护一个左+右的最大值）</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number&#125;
 */
var diameterOfBinaryTree = function (root) &#123;
  let ans = 0;
  const maxDepth = (root) =&gt; &#123;
    if (!root) return 0;
    let left = maxDepth(root.left);
    let right = maxDepth(root.right);
    ans = Math.max(ans, left + right);
    return Math.max(left, right) + 1;
  &#125;;
  maxDepth(root);
  return ans;
&#125;;
</code></pre>
<ul>
<li>二叉树的层序遍历</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[][]&#125;
 */
var levelOrder = function (root) &#123;
  if (!root) return [];
  let result = [];
  let queue = [root];
  while (queue.length) &#123;
    let currentQueue = [];
    let currentLevel = queue.length;
    for (let i = 0; i &lt; currentLevel; i++) &#123;
      let current = queue.shift();
      currentQueue.push(current.val);
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    &#125;
    result.push(currentQueue);
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>将有序数组转换为二叉搜索树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;number[]&#125; nums
 * @return &#123;TreeNode&#125;
 */
var sortedArrayToBST = function (nums) &#123;
  if (nums.length === 0) return null;
  const mid = Math.floor(nums.length / 2);
  const root = new TreeNode(nums[mid]);
  root.left = sortedArrayToBST(nums.slice(0, mid));
  root.right = sortedArrayToBST(nums.slice(mid + 1));
  return root;
&#125;;
</code></pre>
<ul>
<li>验证二叉搜索树（注意左边所有数字都要小于根）</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;boolean&#125;
 */
var isValidBST = function (root) &#123;
  const helper = (node, min, max) =&gt; &#123;
    if (!node) return true;
    if (node.val &lt;= min || node.val &gt;= max) return false;
    return (
      helper(node.left, min, node.val) &amp;&amp; helper(node.right, node.val, max)
    );
  &#125;;
  return helper(root, -Infinity, Infinity);
&#125;;
</code></pre>
<ul>
<li>二叉搜索树中第K小的元素</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var kthSmallest = function (root, k) &#123;
  let arr = [];
  function inOrder(node) &#123;
    if (!node) return null;
    inOrder(node.left);
    arr.push(node.val);
    inOrder(node.right);
  &#125;
  inOrder(root);
  arr.sort((a, b) =&gt; a - b);
  return arr[k - 1];
&#125;;
</code></pre>
<pre><code class="js">//使用非递归方式进行中序遍历
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @param &#123;number&#125; k
 * @return &#123;number&#125;
 */
var kthSmallest = function (root, k) &#123;
  const stack = [];
  while (root || stack.length) &#123;
    while (root) &#123;
      stack.push(root);
      root = root.left;
    &#125;
    root = stack.pop();
    k--;
    if (k === 0) return root.val;
    root = root.right;
  &#125;
&#125;;
</code></pre>
<ul>
<li>二叉树的右视图(先层次遍历，然后取每一个的最后一位)</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;number[]&#125;
 */
var rightSideView = function (root) &#123;
  const arr = levelOrder(root);
  let ans = [];
  arr.map((item) =&gt; &#123;
    ans.push(item[item.length - 1]);
  &#125;);
  return ans;
&#125;;

var levelOrder = function (root) &#123;
  if (!root) return [];
  const res = [];
  const queue = [root];
  let currentLevel = [];
  while (queue.length) &#123;
    let length = queue.length;
    for (let i = 0; i &lt; length; i++) &#123;
      let node = queue.shift();
      currentLevel.push(node.val);
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    &#125;
    res.push(currentLevel);
    currentLevel = [];
  &#125;
  return res;
&#125;;
</code></pre>
<ul>
<li>二叉树展开为链表（前序的顺序展开为链表，使用递归后序遍历）</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;void&#125; Do not return anything, modify root in-place instead.
 */
var flatten = function (root) &#123;
  let prev = null;
  let preOrder = (node) =&gt; &#123;
    if (!node) return;
    preOrder(node.right);
    preOrder(node.left);
    node.right = prev;
    node.left = null;
    prev = node;
  &#125;;
  preOrder(root);
&#125;;
</code></pre>
<ul>
<li>从前序与中序遍历序列构造二叉树</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) &#123;
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * &#125;
 */
/**
 * @param &#123;number[]&#125; preorder
 * @param &#123;number[]&#125; inorder
 * @return &#123;TreeNode&#125;
 */
var buildTree = function (preorder, inorder) &#123;
  if (preorder.length === 0) return null;
  let mid = inorder.indexOf(preorder[0]);
  let root = new TreeNode(preorder[0]);
  root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));
  root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));
  return root;
&#125;;
</code></pre>
<ul>
<li>二叉树的最近公共祖先</li>
</ul>
<pre><code class="js">/**
 * Definition for a binary tree node.
 * function TreeNode(val) &#123;
 *     this.val = val;
 *     this.left = this.right = null;
 * &#125;
 */
/**
 * @param &#123;TreeNode&#125; root
 * @param &#123;TreeNode&#125; p
 * @param &#123;TreeNode&#125; q
 * @return &#123;TreeNode&#125;
 */
var lowestCommonAncestor = function (root, p, q) &#123;
  if (!root || root === p || root === q) &#123;
    return root;
  &#125;
  let left = lowestCommonAncestor(root.left, p, q);
  let right = lowestCommonAncestor(root.right, p, q);
  if (!left) return right;
  if (!right) return left;
  return root;
&#125;;
</code></pre>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><ul>
<li>岛屿数量（dfs次数）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;character[][]&#125; grid
 * @return &#123;number&#125;
 */
var numIslands = function (grid) &#123;
  let m = grid.length;
  let n = grid[0].length;
  let count = 0;
  let xx = [-1, 0, 1, 0];
  let yy = [0, 1, 0, -1];
  const dfs = (grid, i, j) =&gt; &#123;
    if (i &lt; 0 || j &lt; 0 || i &gt;= m || j &gt;= n || grid[i][j] !== &quot;1&quot;) &#123;
      return;
    &#125;
    grid[i][j] = &quot;2&quot;;
    for (let k = 0; k &lt; 4; k++) &#123;
      dfs(grid, i + xx[k], j + yy[k]);
    &#125;
  &#125;;
  for (let i = 0; i &lt; m; i++) &#123;
    for (let j = 0; j &lt; n; j++) &#123;
      if (grid[i][j] === &quot;1&quot;) &#123;
        count++;
        dfs(grid, i, j);
      &#125;
    &#125;
  &#125;

  return count;
&#125;;
</code></pre>
<ul>
<li>腐烂的橘子</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[][]&#125; grid
 * @return &#123;number&#125;
 */
var orangesRotting = function (grid) &#123;
  let queue = [];
  let fresh = 0;
  let time = 0;
  let m = grid.length;
  let n = grid[0].length;
  let move = [
    [0, 1],
    [0, -1],
    [1, 0],
    [-1, 0],
  ];
  for (let i = 0; i &lt; m; i++) &#123;
    for (let j = 0; j &lt; n; j++) &#123;
      if (grid[i][j] === 2) queue.push([i, j]);
      if (grid[i][j] === 1) fresh++;
    &#125;
  &#125;
  while (queue.length) &#123;
    let size = queue.length;
    for (i = 0; i &lt; size; i++) &#123;
      let [x, y] = queue.shift();
      for (let [dx, dy] of move) &#123;
        let xx = x + dx;
        let yy = y + dy;
        if (xx &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; grid[xx][yy] === 1) &#123;
          grid[xx][yy] = 2;
          fresh--;
          queue.push([xx, yy]);
        &#125;
      &#125;
    &#125;
    time++;
  &#125;
  return fresh ? -1 : Math.max(0, time - 1);
&#125;;
</code></pre>
<ul>
<li>课程表（bfs，记录入度和每个课程的后续课程）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; numCourses
 * @param &#123;number[][]&#125; prerequisites
 * @return &#123;boolean&#125;
 */
var canFinish = function (numCourses, prerequisites) &#123;
  let inDegree = new Array(numCourses).fill(0);
  let map = new Map();
  let count = 0;
  for (let i = 0; i &lt; prerequisites.length; i++) &#123;
    if (map.has(prerequisites[i][1])) &#123;
      map.get(prerequisites[i][1]).push(prerequisites[i][0]);
    &#125; else &#123;
      map.set(prerequisites[i][1], [prerequisites[i][0]]);
    &#125;
    inDegree[prerequisites[i][0]]++;
  &#125;
  let queue = [];
  for (let i = 0; i &lt; numCourses; i++) &#123;
    if (inDegree[i] === 0) &#123;
      queue.push(i);
    &#125;
  &#125;
  while (queue.length) &#123;
    let current = queue.shift();
    count++;
    let children = map.get(current);
    children &amp;&amp;
      children.map((child) =&gt; &#123;
        inDegree[child]--;
        if (inDegree[child] === 0) &#123;
          queue.push(child);
        &#125;
      &#125;);
  &#125;
  return count === numCourses;
&#125;;
</code></pre>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><ul>
<li>全排列</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var permute = function (nums) &#123;
  let res = [];
  if (!nums.length) return res;
  const dfs = (path) =&gt; &#123;
    if (path.length === nums.length) &#123;
      res.push(path);
      return;
    &#125;
    for (let i = 0; i &lt; nums.length; i++) &#123;
      if (!path.includes(nums[i])) &#123;
        dfs(path.concat(nums[i]));
      &#125;
    &#125;
  &#125;;
  dfs([]);
  return res;
&#125;;
</code></pre>
<ul>
<li>子集（重做）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number[][]&#125;
 */
var subsets = function (nums) &#123;
  let result = [];
  let dfs = (start, path) =&gt; &#123;
    result.push(path);
    for (let i = start; i &lt; nums.length; i++) &#123;
      dfs(i + 1, [...path, nums[i]]);
    &#125;
  &#125;;
  dfs(0, []);
  return result;
&#125;;
</code></pre>
<ul>
<li>电话号码的字母组合</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; digits
 * @return &#123;string[]&#125;
 */
var letterCombinations = function (digits) &#123;
  if (digits.length === 0) return [];
  let map = &#123;
    2: &quot;abc&quot;,
    3: &quot;def&quot;,
    4: &quot;ghi&quot;,
    5: &quot;jkl&quot;,
    6: &quot;mno&quot;,
    7: &quot;pqrs&quot;,
    8: &quot;tuv&quot;,
    9: &quot;wxyz&quot;,
  &#125;;
  let result = [];

  const dfs = (index, str) =&gt; &#123;
    if (index === digits.length) &#123;
      result.push(str);
      return;
    &#125;
    for (let i = 0; i &lt; map[digits[index]].length; i++) &#123;
      dfs(index + 1, str + map[digits[index]][i]);
    &#125;
  &#125;;
  dfs(0, &quot;&quot;);
  return result;
&#125;;
</code></pre>
<ul>
<li>组合总和（先找数再去重）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; candidates
 * @param &#123;number&#125; target
 * @return &#123;number[][]&#125;
 */
var combinationSum = function (candidates, target) &#123;
  let set = new Set();
  let result = [];
  const dfs = (path, sum) =&gt; &#123;
    if (sum &gt; target) return;
    if (sum === target) &#123;
      path.sort((a, b) =&gt; a - b);
      set.add(JSON.stringify(path));
      return;
    &#125;
    for (let i = 0; i &lt; candidates.length; i++) &#123;
      dfs(path.concat(candidates[i]), sum + candidates[i]);
    &#125;
  &#125;;
  dfs([], 0);
  result = Array.from(set).map((item) =&gt; JSON.parse(item));
  return result;
&#125;;
</code></pre>
<ul>
<li>括号生成(左右括号数量)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; n
 * @return &#123;string[]&#125;
 */
var generateParenthesis = function (n) &#123;
  if (n &lt;= 0) return [];
  let result = [];
  const dfs = (left, right, str) =&gt; &#123;
    if (!left &amp;&amp; !right) &#123;
      result.push(str);
      return;
    &#125;
    if (left === right) &#123;
      dfs(left - 1, right, str + &quot;(&quot;);
    &#125; else if (left &lt; right) &#123;
      if (left &gt; 0) dfs(left - 1, right, str + &quot;(&quot;);
      dfs(left, right - 1, str + &quot;)&quot;);
    &#125;
  &#125;;
  dfs(n, n, &quot;&quot;);
  return result;
&#125;;
</code></pre>
<ul>
<li>单词搜索</li>
</ul>
<pre><code class="js">/**
 * @param &#123;character[][]&#125; board
 * @param &#123;string&#125; word
 * @return &#123;boolean&#125;
 */
var exist = function (board, word) &#123;
  let m = board.length;
  let n = board[0].length;
  let move = [
    [0, 1],
    [1, 0],
    [0, -1],
    [-1, 0],
  ];
  let ans = false;
  let visited = Array(m)
    .fill(0)
    .map(() =&gt; Array(n).fill(false));

  const dfs = (x, y, word) =&gt; &#123;
    if (board[x][y] !== word[0]) return;
    if (word.length === 1) &#123;
      ans = true;
      return;
    &#125;
    visited[x][y] = true;
    for (let i = 0; i &lt; 4; i++) &#123;
      let xx = x + move[i][0];
      let yy = y + move[i][1];
      if (xx &gt;= 0 &amp;&amp; yy &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &lt; n &amp;&amp; !visited[xx][yy]) &#123;
        dfs(xx, yy, word.substring(1));
        visited[xx][yy] = false;
      &#125;
    &#125;
  &#125;;
  for (let i = 0; i &lt; m; i++) &#123;
    let index = board[i].indexOf(word[0]);
    while (index !== -1 &amp;&amp; !ans) &#123;
      dfs(i, index, word);
      visited[i][index] = false;
      index = board[i].indexOf(word[0], index + 1);
    &#125;
  &#125;
  return ans;
&#125;;
</code></pre>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><ul>
<li>搜索插入位置</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number&#125;
 */
var searchInsert = function (nums, target) &#123;
  let left = 0;
  let right = nums.length - 1;
  while (left &lt;= right) &#123;
    let mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) &#123;
      return mid;
    &#125; else if (nums[mid] &lt; target) &#123;
      left = mid + 1;
    &#125; else &#123;
      right = mid - 1;
    &#125;
  &#125;
  return left;
&#125;;
</code></pre>
<ul>
<li>搜索二维矩阵（二维二分，注意 边界）</li>
</ul>
<pre><code class="JS">/**
 * @param &#123;number[][]&#125; matrix
 * @param &#123;number&#125; target
 * @return &#123;boolean&#125;
 */
var searchMatrix = function (matrix, target) &#123;
  if (matrix.length === 0 || matrix[0].length === 0) &#123;
    return false;
  &#125;
  if (
    target &lt; matrix[0][0] ||
    target &gt; matrix[matrix.length - 1][matrix[0].length - 1]
  )
    return false;
  let m = matrix.length;
  let n = matrix[0].length;

  const getRow = () =&gt; &#123;
    let l = 0;
    let r = m - 1;
    while (l &lt;= r) &#123;
      let mid = Math.floor((l + r) / 2);
      if (matrix[mid][0] &lt;= target &amp;&amp; matrix[mid][n - 1] &gt;= target) &#123;
        return mid;
      &#125; else if (matrix[mid][0] &gt; target) &#123;
        r = mid - 1;
      &#125; else &#123;
        l = mid + 1;
      &#125;
    &#125;
    return l;
  &#125;;
  const row = getRow();
  let l = 0;
  let r = n - 1;
  while (l &lt;= r) &#123;
    let mid = Math.floor((l + r) / 2);
    if (matrix[row][mid] === target) &#123;
      return true;
    &#125; else if (matrix[row][mid] &lt; target) &#123;
      l = mid + 1;
    &#125; else &#123;
      r = mid - 1;
    &#125;
  &#125;
  return matrix[row][l] === target;
&#125;;
</code></pre>
<ul>
<li>在排序数组中查找元素的第一个和最后一个位置(取巧，找target+0.5和-0.5)</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number[]&#125;
 */
var searchRange = function (nums, target) &#123;
  let target1 = target - 0.5;
  let target2 = target + 0.5;

  const find = (target) =&gt; &#123;
    let l = 0,
      r = nums.length - 1;
    while (l &lt;= r) &#123;
      let mid = Math.floor((l + r) / 2);
      if (nums[mid] &lt; target) &#123;
        l = mid + 1;
      &#125; else &#123;
        r = mid - 1;
      &#125;
    &#125;
    return l;
  &#125;;
  let left = find(target1);
  let right = find(target2);
  if (nums[left] === target &amp;&amp; nums[right - 1] === target) &#123;
    return [left, right - 1];
  &#125; else &#123;
    return [-1, -1];
  &#125;
&#125;;
</code></pre>
<ul>
<li>搜索旋转排序数组</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @param &#123;number&#125; target
 * @return &#123;number&#125;
 */
var search = function (nums, target) &#123;
  let l = 0,
    r = nums.length - 1;
  while (l &lt;= r) &#123;
    let mid = Math.floor((l + r) / 2);
    if (nums[mid] === target) return mid;
    if (nums[l] &lt;= nums[mid]) &#123;
      if (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) r = mid - 1;
      else l = mid + 1;
    &#125; else &#123;
      if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) l = mid + 1;
      else r = mid - 1;
    &#125;
  &#125;
  return -1;
&#125;;
</code></pre>
<ul>
<li>寻找旋转排序数组中的最小值</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var findMin = function (nums) &#123;
  let l = 0;
  let r = nums.length - 1;
  while (l &lt;= r) &#123;
    if (l === r) &#123;
      return nums[l];
    &#125;
    let mid = Math.floor((l + r) / 2);
    if (nums[mid] &lt; nums[r]) &#123;
      r = mid;
    &#125; else &#123;
      l = mid + 1;
    &#125;
  &#125;
  return nums[l];
&#125;;
</code></pre>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>括号匹配</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;boolean&#125;
 */
var isValid = function (s) &#123;
  let stack = [];
  let map = &#123;
    &quot;(&quot;: &quot;)&quot;,
    &quot;&#123;&quot;: &quot;&#125;&quot;,
    &quot;[&quot;: &quot;]&quot;,
  &#125;;
  for (let i = 0; i &lt; s.length; i++) &#123;
    if (s[i] === &quot;(&quot; || s[i] === &quot;&#123;&quot; || s[i] === &quot;[&quot;) &#123;
      stack.push(s[i]);
    &#125; else &#123;
      let last = stack.pop();
      if (s[i] !== map[last]) &#123;
        return false;
      &#125;
    &#125;
  &#125;
  return stack.length === 0;
&#125;;
</code></pre>
<ul>
<li>最小栈</li>
</ul>
<pre><code class="js">var MinStack = function () &#123;
  this.stack = [];
  this.minStack = [];
&#125;;

/**
 * @param &#123;number&#125; val
 * @return &#123;void&#125;
 */
MinStack.prototype.push = function (val) &#123;
  this.stack.push(val);
  if (
    this.minStack.length === 0 ||
    val &lt;= this.minStack[this.minStack.length - 1]
  ) &#123;
    this.minStack.push(val);
  &#125; else &#123;
    this.minStack.push(this.minStack[this.minStack.length - 1]);
  &#125;
&#125;;

/**
 * @return &#123;void&#125;
 */
MinStack.prototype.pop = function () &#123;
  this.stack.pop();
  this.minStack.pop();
&#125;;

/**
 * @return &#123;number&#125;
 */
MinStack.prototype.top = function () &#123;
  return this.stack[this.stack.length - 1];
&#125;;

/**
 * @return &#123;number&#125;
 */
MinStack.prototype.getMin = function () &#123;
  return this.minStack[this.minStack.length - 1];
&#125;;

/**
 * Your MinStack object will be instantiated and called as such:
 * var obj = new MinStack()
 * obj.push(val)
 * obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.getMin()
 */
</code></pre>
<ul>
<li>字符串编码</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;string&#125;
 */
var decodeString = function (s) &#123;
  let queue = [];
  let ans = &quot;&quot;;
  for (let i = 0; i &lt; s.length; i++) &#123;
    if (s[i] !== &quot;]&quot;) &#123;
      queue.push(s[i]);
    &#125; else &#123;
      let current = queue.pop();
      let temp = &quot;&quot;;
      let count = 0;
      let times = 0;
      while (current !== &quot;[&quot;) &#123;
        temp = current + temp;
        current = queue.pop();
      &#125;
      while (queue.length &gt; 0 &amp;&amp; !isNaN(queue[queue.length - 1])) &#123;
        count = count + Math.pow(10, times) * parseInt(queue.pop());
        times++;
      &#125;
      queue.push(temp.repeat(count));
    &#125;
  &#125;
  return queue.join(&quot;&quot;);
&#125;;
</code></pre>
<ul>
<li>每日温度</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; temperatures
 * @return &#123;number[]&#125;
 */
var dailyTemperatures = function (temperatures) &#123;
  let ans = new Array(temperatures.length).fill(0);
  let queue = [];
  for (let i = 0; i &lt; temperatures.length; i++) &#123;
    if (!queue.length) &#123;
      queue.push(&#123; index: i, value: temperatures[i] &#125;);
    &#125; else &#123;
      let top = queue[queue.length - 1];
      if (temperatures[i] &lt; top.value) &#123;
        queue.push(&#123; index: i, value: temperatures[i] &#125;);
      &#125; else &#123;
        while (
          queue.length &amp;&amp;
          temperatures[i] &gt; queue[queue.length - 1].value
        ) &#123;
          let top = queue.pop();
          ans[top.index] = i - top.index;
        &#125;
        queue.push(&#123; index: i, value: temperatures[i] &#125;);
      &#125;
    &#125;
  &#125;
  return ans;
&#125;;
</code></pre>
<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul>
<li>买卖股票的最佳时机</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; prices
 * @return &#123;number&#125;
 */
var maxProfit = function(prices) &#123;
    let min = Infinity;
    let max = 0;
    for(let i=0;i&lt;prices.length;i++)&#123;
        if(prices[i]&lt;min)&#123;
            min = prices[i];
        &#125;
        max = Math.max(max,prices[i]-min);
    &#125;
    return max;
&#125;;
</code></pre>
<ul>
<li>跳跃游戏（倒序遍历）</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;boolean&#125;
 */
var canJump = function(nums) &#123;
    if(nums.length&lt;=1) return true;
    let len = 1;
    for(let i = nums.length-2;i&gt;0;i--)&#123;
        if(nums[i]&gt;=len)&#123;
            len = 1;
        &#125;else&#123;
            len++;
        &#125;
    &#125;
    if(nums[0]&gt;=len) return true;
    return false;
&#125;;
</code></pre>
<ul>
<li>跳跃游戏II</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var jump = function(nums) &#123;
    let ans = 0;
    let maxPos = 0;
    let end = 0;
    for(let i=0;i&lt;nums.length-1;i++)&#123;
        maxPos = Math.max(maxPos,i+nums[i]);
        if(end===i)&#123;
            end = maxPos; 
            ans++;
        &#125;
    &#125;
    return ans;
&#125;;
</code></pre>
<ul>
<li>划分字母区间</li>
</ul>
<pre><code class="js">/**
 * @param &#123;string&#125; s
 * @return &#123;number[]&#125;
 */
var partitionLabels = function(s) &#123;
    let start = 0;
    let end = 0;
    let ans = [];
    let last = [];
    for(let i = 0;i&lt;s.length;i++)&#123;
        last[s[i]] = i;
    &#125;
    for(let i=0;i&lt;s.length;i++)&#123;
        end = Math.max(end,last[s[i]]);
        if(i===end)&#123;
            ans.push(end-start+1);
            start = end+1;
        &#125;
    &#125;
    return ans;
&#125;;
</code></pre>
<ul>
<li>爬楼梯</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var climbStairs = function (n) &#123;
  let dp = new Array(n + 1).fill(0);
  dp[0] = 1;
  dp[1] = 1;
  for (let i = 2; i &lt;= n; i++) &#123;
    dp[i] = dp[i - 1] + dp[i - 2];
  &#125;
  return dp[n];
&#125;;
</code></pre>
<ul>
<li>杨辉三角</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; numRows
 * @return &#123;number[][]&#125;
 */
var generate = function (numRows) &#123;
  const result = [];
  for (let i = 0; i &lt; numRows; i++) &#123;
    const row = [];
    for (let j = 0; j &lt;= i; j++) &#123;
      if (j === 0 || j === i) &#123;
        row.push(1);
      &#125; else &#123;
        row.push(result[i - 1][j - 1] + result[i - 1][j]);
      &#125;
    &#125;
    result.push(row);
  &#125;
  return result;
&#125;;
</code></pre>
<ul>
<li>打家劫舍</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var rob = function (nums) &#123;
  if (nums.length &lt; 2) &#123;
    return nums[0];
  &#125;
  let dp = new Array(nums.length).fill(0);
  dp[0] = nums[0];
  dp[1] = Math.max(nums[0], nums[1]);
  for (let i = 2; i &lt; nums.length; i++) &#123;
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
  &#125;
  return dp[nums.length - 1];
&#125;;
</code></pre>
<ul>
<li>完全平方数</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number&#125; n
 * @return &#123;number&#125;
 */
var numSquares = function (n) &#123;
  let dp = new Array(n + 1).fill(0);
  for (let i = 1; i &lt;= n; i++) &#123;
    let min = Infinity;
    for (let j = 1; j * j &lt;= i; j++) &#123;
      min = Math.min(min, dp[i - j * j]);
    &#125;
    dp[i] = min + 1;
  &#125;
  return dp[n];
&#125;;
</code></pre>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul>
<li>只出现一次的数字</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var singleNumber = function (nums) &#123;
  let ans = nums[0];
  for (let i = 1; i &lt; nums.length; i++) &#123;
    ans ^= nums[i];
  &#125;
  return ans;
&#125;;
</code></pre>
<ul>
<li>多数元素</li>
</ul>
<pre><code class="js">/**
 * @param &#123;number[]&#125; nums
 * @return &#123;number&#125;
 */
var majorityElement = function(nums) &#123;
    let ans = 0;
    let count = 0;
    for(let i=0;i&lt;nums.length;i++)&#123;
        if(count===0)&#123;
            ans = nums[i];
        &#125;
        if(ans===nums[i])&#123;
            count++;
        &#125;else&#123;
            count--;
        &#125;
    &#125;
    return ans;
&#125;;
</code></pre>

    </div>

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <div id="comment">
        <div id="gitalk-container">
        </div>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2021 - 2024 摸鱼日志
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @Like Frost
        </div>
        <div></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: '8249c57ec1e7d39c84e2',
        clientSecret: 'bdce24bd67025b8164bd420f6412441f3635ebd8',
        repo: 'comment',      // The repository of store comments,
        owner: 'LikeFrost',
        admin: ['LikeFrost'],
        language: 'zh-CN',
        id: decodeURI(location.pathname),      // Ensure uniqueness and length less than 50
        distractionFreeMode: true  // Facebook-like distraction free mode
    })
    gitalk.render('gitalk-container')
</script>

</body>

</html>